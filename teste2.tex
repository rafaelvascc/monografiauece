\documentclass[a4paper,12pt]{article}
\usepackage[brazilian]{babel}
\usepackage[section]{placeins}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst} %Margem no primeiro paragrafo
\usepackage{hyperref} %Urls
\usepackage[left=3cm,top=3cm,right=2cm,bottom=2cm]{geometry}
\usepackage{graphicx} %figuras
\usepackage{helvet} %fonte arial
\usepackage{caption}
\usepackage{setspace}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{newfloat}
\usepackage{listings}
\setlength{\parskip}{1em}
\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\lstlisting}{\arabic{lstlisting}}
\renewcommand{\lstlistingname}{Código}

\lstset{aboveskip=20pt,belowskip=20pt}

\newenvironment{simple}%
{\noindent}%
{\par\noindent}

\graphicspath{ {figuras/} }

\newcommand{\anmvc} {
\sigla{ASP.NET MVC} 5
}

\newcommand{\spring} {
\lang{Java}/\est{Spring} \sigla{MVC}
}

\newcommand{\mysql} {
\est{MySQL}
}

\newcommand{\figura}[3] {
	\begin{figure}[ht]
		\centering
		\includegraphics{#1}
		\caption{#2}
		\label{#3}
	\end{figure}
	\FloatBarrier
}

\newcommand{\est}[1] {
\textit{#1}}

\newcommand{\classe}[1] {
\textit{#1}}

\newcommand{\arquivo}[1] {
\textit{#1}}

\newcommand{\sigla}[1] {
\textit{#1}}

\newcommand{\lang}[1] {
\textit{#1}}

\newcommand{\lib}[1] {
\textit{#1}} 

\newcommand{\annotation}[1] {
\textit{#1}}

\newcommand{\pacote}[1] {
\textit{#1}}

\newcommand{\metodo}[1] {
\textit{#1}}

\newcommand{\groovycode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=Java, label=#3]{#1}
}

\newcommand{\javacode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=Java,label=#3]{#1}
	%\FloatBarrier
}

\newcommand{\sharpcode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=C,label=#3]{#1}
	%\FloatBarrier
}

\newcommand{\xmlcode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=XML,label=#3]{#1}
	%\FloatBarrier
}

\newcommand{\jspcode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=HTML,label=#3]{#1}
	%\FloatBarrier
}

\newcommand{\razorcode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=HTML,label=#3]{#1}
	%\FloatBarrier
}

\begin{document}
\title{Comparação de desenvolvimento de aplicações web com ASP.NET MVC 5 e Spring MVC 4}
\author{José Rafael Vasconcelos Cavalcante}
\date{January 5, 2011}
\maketitle

\newpage
\section{Introdução}

\subsection{Objetivo}

Este trabalho tem como objetivo comparar a criação de uma aplicação utilizando duas tecnologias, \textit{Java} com o \lib{Spring Framework} e \lib{Hibernate}, e o \sigla{ASP.NET MVC 5} e \textit{Entity Framework} utilizando \lang{C\#}. é usado como exemplo, a criação de um projeto de uma aplicação web de três camadas (apresentação, serviços e persistência) que utiliza o padrão \est{Model View Controller} (\sigla{MVC}).

A abordagem utilizada consiste em dividir as tarefas necessárias para a criação da aplicação em cinco capítulos, e nesses capítulos serão demonstrados exemplos de código com as duas tecnologias. Depois de expostos os exemplos de como executar as tarefas, serão ressaltadas as vantagens, desvantagens e características distintas de cada tecnologia. As tarefas a serem executadas serão as seguintes:

\begin{itemize}
  \item Preparação do ambiente de desenvolvimento.
  \item Criação e configuração de um novo projeto.
  \item Criação de \est{controllers}.
  \item Criação de \est{views}.
  \item Criação de classes de serviço.
  \item Configuração de injeção de dependências.
  \item Criação de entidades.
  \item Criação de repositórios.
\end{itemize}

\subsection{Estado da arte}
 
No momento de criação desse trabalho, a literatura conta com vários trabalhos sobre medição de desempenho de aplicações \est{web} e poucos comparando como se cria uma aplicação. E mesmos trabalhos comparando o esforço do desenvolvimento de aplicações utilizando tecnologias diferentes, utilizam versões antigas de tais tecnologias. 

Atul Mishra em seu trabalho \est{"Critical Comparison Of PHP And ASP.NET For Web Development"}, por exemplo, compara a criação de um site utilizando uma versão antiga do \sigla{ASP.NET} e utilizando \sigla{PHP}. Nesse trabalho não são expostos exemplos de código, apenas as conclusões tiradas pelo autor. Mostafa Pordel e Faranhaz Yekeh, autores do artigo "\est{"JSF vs ASP.NET, what are their limits?"} também comparam o desenvolvimento de aplicações \est{web} utilizando as tecnologias \lang{Java} e \lib{.NET}. Mas também utilizam versões antigas de ambas as tecnologias e mostram poucos exemplos de código.

Tiago Bencardino, em seu trabalho de conclusão do curso de engenharia de teleinformática de titulo "\est{iQuizzer}: Integrando aplicações web e dispositivos móveis em um ambiente para criação e execução de \est{quizzes}", comparou o desenvolvimento de uma aplicação para as plataformas moveis \est{Android} e \est{iOS}. Bencardino utilizou uma quantidade maior de exemplos de código, comparando o desenvolvimento das mesmas tarefas em ambas as plataformas alvos de seu trabalho.

\subsection{Resumo dos resultados alcançados}

Ambas as tecnologias possuem seus pontos fortes e fracos. De modo geral, o uso de \lang{Java} com o \lib{Spring Framework} proporciona melhor controle do projeto ao desenvolvedor e a liberdade de utilizar uma gama maior de bibliotecas para sua configuração. Mas essa liberdade tem um custo, o desenvolvedor de modo geral, precisa escrever mais código de configuração e pesquisar como os componentes escolhidos interagem para que o projeto seja bem sucedido.

A tecnologia \sigla{ASP.NET MVC} é mais fechada (apesar de ter seu código ser aberto), existem muitas convenções que o desenvolvedor deve obedecer e não existe tanta liberdade para configuração, tudo é mais padronizado. A vantagem disso é que o desenvolvedor se preocupa menos em como vai configurar sua aplicação e ele pode usar esse tempo para escrever código que realmente agrega valor ao produto.

De modo geral, se o desenvolvedor dispuser de tempo e precisar de um controle maior sobre o projeto, o uso da tecnologia \lang{Java} é aconselhável. Por outro lado, se o projeto tiver um prazo reduzido ou o desenvolvedor preferir seguir convenções e não quiser se preocupar em como vai ter que configurar o projeto, a tecnologia \lib{.NET} pode ser uma melhor opção.
 
\subsection{Publico alvo}

Esse trabalho pode beneficiar gerentes de projetos e lideres técnicos à escolher qual das duas tecnologias utilizar para iniciar um novo projeto. Estudantes interessados em começar a desenvolver para a \est{web} também podem se beneficiar desse trabalho e aprender o básico sobre as duas tecnologias.

\subsection{Metodologia de pesquisa}

A maior fonte da informação para esse trabalho foram livros, em sua maioria as edições mais recentes. Além dos livros, foram utilizados como fonte de pesquisa as documentações online de ambas as tecnologias. Também foram utilizados como fonte de pesquisa, exemplos encontrados em sites de desenvolvedores na internet, sendo o mais utilizado o \est{stack overflow} americano.

\newpage
\section{Configuração de ambiente de desenvolvimento}

Neste capitulo é demonstrado o preparo do ambiente de desenvolvimento em um computador rodando o sistema operacional \est{Windows 8.1} de 64 \est{bits}. Primeiramente, instala-se um sistema gerenciador de banco de dados para trabalhar tanto com a plataforma \spring quanto com a plataforma \anmvc.  O banco de dados usado é o \est{MySQL Community Server} versão 5.6.22 (a versão mais atual até o momento de criação desta monografia). A \est{Integrated Development Environment} (\sigla{IDE}) utilizada  para escrever código em \lang{Java}, é o \est{Eclipse Luna}. O \est{Gradle} é usado como \est{build tool} e o \est{Apache Tomcat} como \est{container} \est{Java Enterprise Edition} (\sigla{JEE}). Para desenvolver em \lang{C\#}, é usado o \est{Visual Studio 2013 Community}. Considerando que o leitor já possui entendimentos sobre informática necessários para instalar programas no \est{Windows}, as instruções de instalação serão sucintas. 

\subsection{Instalação do MySQL}

O download do instalador do \est{MySQL Community} foi feito no seguinte endereço \url{https://dev.mysql.com/downloads/windows/installer/5.6.html}. O instalador está disponível duas versões, \est{web installer} e \est{off-line installer}. O \est{web installer} é um arquivo pequeno que quando executado irá baixar os arquivos do \sigla{MySQL} para a máquina, o \est{off-line installer} é maior e vem com todos os arquivos necessários para a  instalação do \sigla{MySQL}. Qualquer que seja o método de instalação escolhido, eles terão as mesmas opções.

Executando o instalador, é escolhida a opção \est{Custom} e na árvore de opções que aparecerá na tela a seguir, são escolhidos o \est{MySQL Server}, o \est{MySQL Workbench}, o \est{Connector/J} (para \lang{Java}) e o \est{Connector/NET} (para \sigla{.NET}), como mostrado na Figura~\ref{fig:sql1}. Pode acontecer do instalador pedir para instalar o \est{Microsoft Visual C++ 2013} como dependência do \est{MySQL Workbench}, se isso acontecer, o próprio instalador proverá um botão para instalar essa dependência.

\figura{mysqlinstaller1.jpg}{Opções de instalação do \mysql}{fig:sql1}

Concluída a instalação, é hora de configurar o serviço do \sigla{MySQL}. Deixa-se selecionado o tipo de configuração como \est{Development Machine} e as configurações de rede padrão (protocolo \sigla{TCP/IP}, porta 3306). Quando for necessária a senha do usuário \est{Root}, é usada “1234”, é uma senha fraca que não se recomenda usar em ambiente de produção, mas serve para propósito de exemplo. Finaliza-se a configuração deixando marcados os restantes das opções de configuração como padrão do instalador.

Com o objetivo de testar o sucesso da instalação, o desenvolvedor pode executar o \est{MySQL Workbench}, como ilustrado na Figura~\ref{fig:sql2}, e tentar se conectar à instancia do MySQL.

\figura{mysqlinstaller2.jpg}{O \mysql \est{Workbench}}{fig:sql2}

Para mais informações sobre o \sigla{MySQL}, visite a página oficial do projeto, \url{https://www.mysql.com/}.

\subsection{Preparando o ambiente \lang{Java}}

Para desenvolver em \lang{Java}, é utilizado o \est{Eclipse Luna} e o \est{Java Development Kit 8} (\sigla{JDK 8}). é usado o \est{Gradle} como \est{build tool} através de um \est{plugin} do \est{Eclipse} e o servidor \est{web} utilizado é o \est{Apache Tomcat}.

\subsubsection{Instalando JDK 8}

O instalador do \sigla{JDK 8} pode ser adquirido no endereço \url{http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html}. Existem diversas versões para diversos sistemas operacionais, é usado nesse trabalho a versão para \est{Windows} de 64 \est{bits}. 

Para fazer a instalação do \sigla{JDK}, é executado o arquivo de instalação seguindo as suas instruções. A única configuração possível durante a instalação é a mudança da sua pasta de destino, mas é mantido o diretório padrão como mostrado na Figura~\ref{fig:jdk1}.

\figura{jdk81.jpg}{O instalador do \sigla{JDK 8}}{fig:jdk1}

Terminada a instalação, é necessário configurar a variável \est{PATH} para que o sistema encontre os arquivos do \lang{Java}. Essas opções de configuração estão no painel de controle do \est{Windows}, no caminho Sistema/Configurações avançadas do sistema/Variáveis de ambiente. Na janela de variáveis do sistema, é editada a variável \est{PATH}. Se adiciona o caminho onde o \sigla{JDK} foi instalado acrescido da pasta bin (C:\textbackslash Program Files\textbackslash Java\textbackslash jdk\textmd{1.8.0\_25}\textbackslash bin) como mostrado na Figura~\ref{fig:path}.

\figura{path1.png}{Configurando a variável \est{PATH}}{fig:path}

Para testar se tudo foi instalado corretamente, abre-se uma janela do \est{prompt} de comando e digita-se o comando \est{“java –version”} (sem aspas). Se não existirem problemas, é exibida na tela o número da versão do \sigla{JDK} instalado. Caso isso não aconteça, é aconselhável desinstalar o \sigla{JDK} e repetir o processo de instalação. 

\subsubsection{Instalando o \est{Eclipse Luna}} 

O \est{Eclipse Luna} para Desenvolvedores \est{Java EE} é encontrado no endereço \url{https://www.eclipse.org/downloads/}. Terminando o \est{download}, a pasta \est{“eclipse”} pode ser descompactada para qualquer diretório do computador. Coloca-se um atalho na sua área de trabalho para o executável do \est{Eclipse} (eclipse.exe) para facilitar o acesso.

Na primeira vez que o \est{Eclipse} é executado é exibida uma janela para configurar o \est{Workspace} padrão (uma pasta onde serão guardados projetos e configurações), como está ilustrado na Figura~\ref{fig:eclipse1}.

\figura{eclipse1.png}{\est{Eclipse} recém instalado}{fig:eclipse1}

\subsubsection{Instalando o \est{plugin} do \est{Gradle}} 

O \est{Gradle} é a \est{build tool} que é utilizada nos exemplos do projeto \spring. Ele faz o mesmo trabalho que o \est{ANT} associado ao \est{Ivy} ou o \est{Maven} fazem, mas ele é considerado por alguns autores como o mais moderno em se tratando de \est{build tools}, pois seus \est{scripts} são escritos em \lang{Groovy} em vez de \sigla{XML} e ele permite configurações que o \est{Maven} não permite. O \est{Gradle} está presente em todo ciclo de vida do software (ele gera artefatos, executa teste unitários, resolve dependências e executa integração continua), mas nesse trabalho é usada apenas uma pequena parte do que ele pode oferecer. Para mais informações sobre o \est{Gradle} acesse \url{https://www.gradle.org}. 

No \est{Eclipse Marketplace} (repositório de \est{plugins} do \est{Eclipse}), faz-se uma pesquisa por \est{"Gradle"} na barra de buscas, entre os resultados está o \est{Gradle IDE Pack}. Esse \est{plugin} é usado nos exemplos desse trabalho. O \est{Eclipse} pede confirmação para instalação de todos os pacotes necessários, todos são selecionados e instalados. Aceita-se os termos de uso do \est{Gradle} e ao aparecer uma janela de alerta confirmando a instalação, clica-se em OK. Quando a instalação terminar, o \est{Eclipse} é reiniciado.

Para verificar se o \est{plugin} foi instalado com sucesso, a pasta \est{Gradle} deve aparecer na arvore de tipos de projetos, no menu de novos projetos, como pode ser observado na Figura~\ref{fig:gradle1}.

\figura{plugin1.png}{Instalando o \est{plugin} do \est{Gradle}}{fig:gradle1}

\subsubsection{Instalando o \est{Apache Tomcat 8} como servidor de desenvolvimento do \est{Eclipse}} 

O \est{Java Enterprise Edition} é um conjunto de especificações que precisam ser implementadas por um \est{container} (um servidor de aplicação ou servidor \est{web}) que irá executar efetivamente a aplicação. Existem diversos \est{containers} disponíveis no mercado, sendo o \est{GlassFish} o próprio \est{container} da \est{Oracle}. Nesse trabalho é usado o \est{Apache Tomcat}, pois o \est{Eclipse} tem integração nativa com ele. O \est{Tomcat} pode ser gerenciado pela aba de servidores do \est{Eclipse}.

O instalador do \est{Tomcat 8} pode ser encontrado no endereço \url{https://tomcat.apache.org/download-80.cgi}. Para os exemplos, usa-se a distribuição para \est{Windows} de 64 bits no formato \est{zip}. A pasta \est{apache-tomcat-8.0.15} pode ser descompactada para qualquer diretório no disco rígido (como exemplo é usada a raiz do disco C:).  

Na aba \est{Servers} do Eclipse existe um \est{link} auto descritivo para adicionar um novo servidor. Clicando no \est{link} e expandindo pasta \est{Apache}, é escolhido o \est{Tomcat 8} na árvore de opções, o que pode ser observado na Figura~\ref{fig:tomcat1}. Na janela seguinte, em \est{Tomcat installation directory}, o botão \est{browse...} é usado para escolher o caminho de instalação do \est{Tomcat} (C:\textbackslash apache-tomcat-\textmd{8.0.15}). Clicando no botão \est{Finish}, o \est{Tomcat} está pronto para uso com o \est{Eclipse}. 

\figura{tomcat1.png}{Janela pra adicionar servidores no \est{Eclipse}}{fig:tomcat1}

\subsection{Instalando o \est{Visual Studio Community 2013}} 

O instalador do \est{Visual Studio Community 2013} pode ser encontrado no endereço \url{http://www.visualstudio.com/en-us/news/vs2013-community-vs.aspx}. Na Figura~\ref{fig:vs1} temos uma ilustração do instalador em questão. Esse é um instalador \est{online}, ele baixa os arquivos do \est{Visual Studio} e opcionais selecionados à medida que a instalação for progredindo. Uma imagem do DVD de instalação \est{offline} também está disponível na sessão de \est{downloads} do site \url{http://www.visualstudio.com}.

\figura{vs1.png}{Instalador do Visual Studio Community 2013}{fig:vs1}

Clicando no botão \est{Next}, a próxima tela que o instalador exibe uma lista de componentes opcionais como o \est{kit} de desenvolvimento do \est{Windows Phone 8} e do \est{Silverlight}. Desses componentes opcionais, é aconselhável instalar pelo menos o \est{Microsoft Web Developer Tools} para facilitar o desenvolvimento de aplicações \est{web}.

Após a instalação, o desenvolvedor pode utilizar sua conta da \est{Microsoft} como perfil no \est{Visual Studio} e publicar suas aplicações no \est{Microsoft Azure}, porém isso é opcional. Quando se executa o \est{Visual Studio} pela primeira vez, ilustrado na Figura~\ref{fig:vs2}, o desenvolvedor pode escolher as opções de desenvolvimento e um esquema de cores que irá usar. Como exemplo, é escolhida a opção de desenvolvimento \est{Web Development}.

\figura{vs2.png}{Tela inicial do \est{Visual Studio Community 2013}}{fig:vs2}

O \est{Visual Studio} possui sua própria ferramenta de geração de \est{builds} (\est{MsBuild}), gerenciador de pacotes para obter bibliotecas de terceiros (\est{Nuget}) e um servidor de desenvolvimento minimalista baseado no \est{Internet Information Services} (servidor \est{web} do \est{Windows Server}) para executar e depurar aplicações \est{web}.  

\subsection{Conclusão}

A preparação de um ambiente de desenvolvimento \spring requer mais passos, dentre eles instalar o kit de desenvolvimento do \est{Java}, uma \sigla{IDE} (\est{Eclipse}), um \est{container Java Enterprise Edition} (\est{Tomcat}) e uma \est{build tool} (\est{Gradle}), enquanto  todo o \est{software} necessário para se desenvolver com \sigla{.NET} é adquirido em um único instalador.

A vantagem do ambiente \lang{Java} é que ele fornece ao desenvolvedor mais opções de como configurar seu ambiente, além disso o tamanho em \est{megabytes} do \est{software} necessário é consideravelmente menor do que o ambiente \sigla{.NET}. O desenvolvedor tem a liberdade de escolher outras \est{build tools} disponíveis no mercado (Ex: \est{Ant}, \est{Maven}), outras \sigla{IDEs} (Ex: \est{Netbeans}) e outros servidores \est{Java EE} (Ex: \est{Jetty}, \est{Glassfish}). O lado negativo dessa liberdade é que, com  essa variedade de opções, o desenvolvedor tem que pesquisar mais sobre cada solução até decidir como vai montar seu ambiente de desenvolvimento. Então depois de escolher quais produtos irá utilizar, pode ser que precise de mais algum tempo estudando como eles interagem.

A vantagem do ambiente \sigla{.NET} está na facilidade de obter todo o \est{software} necessário para o desenvolvimento em um único pacote, o \est{.NET Framework}, \est{Visual Studio Community 2013} e demais ferramentas. A desvantagem é que esse pacote pode conter componentes que o desenvolvedor não precisa ou deseja, baixando arquivos desnecessários e tomando espaço em disco.

No próximo capitulo é demonstrado como criar um projeto de uma aplicação \est{web} nas duas plataformas.

\newpage
\section{Criando projetos web no padrão \sigla{MVC}}

Nesse capitulo é mostrado como criar um novo projeto para uma aplicação \est{web} que utiliza o padrão \sigla{MVC} nas plataformas \spring e \anmvc. Para \lang{Java} serão usadas as bibliotecas \est{Spring Framework}, que cuidará da arquitetura \sigla{MVC} e injeção de dependências, e o \est{Hibernate}, que cuidará da persistência e acesso a dados. Na plataforma \sigla{.NET} é utilizado o \sigla{ASP.NET MVC 5}, que cuida de toda estrutura de uma aplicação web \sigla{MVC}, o \est{Entity Framework 6} para acesso a dados e o \est{Ninject} para injeção de dependências.

\subsection{Criando um projeto do \est{Gradle} no \est{Eclipse}}

O modelo de projeto usado nos exemplos desse trabalho é o \est{Gradle Project}. Esse modelo de projeto está localizado na pasta \est{Gradle} na arvore de novos projetos do \est{Eclipse}. Na Figura~\ref{fig:gradleproject} pode-se observar a localização do modelo e a criação do novo projeto.

\figura{gradleproject1.png}{Criando um projeto do \est{Gradle}}{fig:gradleproject}

É criado um projeto com a estrutura mostrada na Figura~\ref{fig:gradletree}.

\figura{gradleproject1.png}{Estrutura inicial de um projeto do \est{Gradle}}{fig:gradletree}

As pastas \arquivo{"src/main/java"} e \arquivo{"src/main/resources"} devem armazenar, respectivamente, código fonte \lang{Java} e recursos utilizados na aplicação.  As pastas \arquivo{"src/test/java"} e \arquivo{"src/test/resources"} são utilizadas para testes unitários. As pastas de testes não serão utilizadas nos exemplos e são removidas. A pasta \est{build} é para onde irão todos os artefatos gerados pelo projeto.

O arquivo \arquivo{build.gradle}, exibido no quadro~\ref{lst:1}, é o arquivo de definição de projeto do \est{Gradle}. Nele podem ser criados \est{scripts} para controlar a construção de artefatos, adquirir bibliotecas de terceiros, configurar testes unitários e realizar várias outras tarefas. Os \est{scripts} do \est{Gradle} são escritos em \lang{Groovy}, outra linguagem compatível com a máquina virtual \lang{Java}. 

\groovycode{code/buildgradle.txt}{O arquivo \est{build.gradle}}{lst:1}

A estrutura do projeto e o arquivo \arquivo{build.gradle} gerados devem ser modificados para servir à uma aplicação \est{web}. é adicionada uma nova pasta, chamada de \est{WebContent}, para armazenar conteúdo especifico para \est{web} (páginas \est{jsp/html}, arquivos \lang{javascript} e \lang{css}). Dentro dela deve ser criada uma pasta chamada \est{WEB-INF} para armazenar páginas \est{jsp}. Por padrão, usuários de sistemas \est{web} \est{Java Enterprise Edition} não possuem acesso direto à pasta \est{WEB-INF}, então é um lugar seguro para armazenar páginas. Na Figura~\ref{fig:12} pode ser observada a estrutura do projeto com a pasta \est{WEB-INF}.

\figura{prrojetocomweninf.png}{Estrutura do projeto com a pasta \est{WebContent}}{fig:12}

Em seguida, é necessário modificar o arquivo \arquivo{build.gradle}. O \est{Gradle} dispõe de vários \est{plugins} que facilitam seu uso em diversas situações e servem a propósitos específicos. Para gerar arquivos \arquivo{.war} (artefatos de aplicações \est{web}) e informar ao \est{Gradle} que a pasta \est{WebContent} armazenará o conteúdo especifico para \est{web}, é utilizado o \est{plugin} chamado \est{war}. Para fazer com que o \est{Eclipse} veja o projeto como um projeto para \est{web} que possa ser enviado para o \est{Tomcat}, é utilizado o \est{plugin} \est{eclipse-wtp}. O início do arquivo \arquivo{build.gradle} deverá ficar como no exemplo do quadro~\ref{lst:2}.

\groovycode{code/newgradle.txt}{Arquivo \arquivo{build.gradle} com novos \est{plugins}}{lst:2}

Com tudo devidamente configurado, é necessário atualizar o tipo de projeto para que o \est{Eclipse} o veja como um projeto de uma aplicação \est{web}. Pressionando Ctrl + Alt + Shift + R o \est{Eclipse} abrirá uma caixa de texto onde poderão ser executadas tarefas do \est{Gradle}. Uma dessas tarefas é o comando \est{"eclipse"} que gera arquivos adicionais para que o projeto possa ser detectado como uma aplicação \est{web}. O comando é executado como na Figura~\ref{fig:13} e o \est{Eclipse} agora poderá publicar a aplicação no \est{Tomcat}.

\figura{gradlecommand.png}{\est{Gradle Task Quick Launcher}}{fig:13}

Após executar esse comando, a estrutura do projeto mudará um pouco. As pastas destinadas a conter código \lang{Java} e bibliotecas usadas no projeto serão movidas para uma pasta chamada \est{Java Resources}.

\subsubsection{Adicionando o projeto ao \est{Tomcat}}

Para adicionar uma aplicação \est{web} ao servidor \est{Tomcat} configurado no \est{Eclipse}, na aba \est{"servers"} dá-se um duplo clique no servidor para abrir suas configurações, e na aba \est{"modules"} clica-se no botão \est{"Add Web Module"}. Escolhido o projeto \est{web} que se deseja adicionar, o caminho da aplicação pode ser configurado. A Figura~\ref{fig:14} ilustra esse procedimento. Com a configuração padrão do \est{Tomcat}, a aplicação estará disponível no endereço com o seguinte formato: \url{http://<endereço-ip>:8080/<caminho-da-aplicação>}. Esse endereço é referenciado no restante do trabalho como raiz da aplicação.

Iniciando o \est{Tomcat}, clicando nos botões \est{"Start the server"} ou \est{"Start the server in debug mode"}, e acessando o endereço da aplicação, é mostrado uma página de erro 404. Isso acontece porque ainda não existem as configurações do \est{servlet} padrão, do \est{Spring MVC} e ainda não foi criado nenhum \est{controller} e nenhuma \est{view}. Nesse capítulo ainda é demonstrado como configurar o \est{servlet} padrão e o \est{Spring MVC}, no capitulo 3 é demonstrado como se criam \est{controllers} e \est{views}.

\figura{tomcatproject.png}{Adicionando um projeto web ao \est{Tomcat}}{fig:14}

\subsubsection{Adicionando dependências ao projeto}

Abaixo estão listadas as bibliotecas que são usadas no projeto \spring. O \est{Gradle} pode adquirir essas bibliotecas e suas dependências do repositório central do \est{Maven}.

\begin{itemize}
  \item \lib{Java Servlet API 3.1.0} - Biblioteca base para programar em \lang{Java} para \est{web} usando \est{servlets}.
  \item \lib{Spring Web MVC 4.1.4 RELEASE} - Biblioteca para criar um projeto \sigla{MVC} com \est{Spring}.
  \item \lib{Spring Transaction 4.1.4 RELEASE} - Gerenciador de transações com o banco de dados.
  \item \lib{Spring Object/Relational Mapping 4.1.4 RELEASE} - Gerenciador de entidades e mapeamento objeto/relacional.
  \item \lib{Jackson Databind 2.5.1} - Serializa e de deserializa objetos \lang{Java} no formato \sigla{JSON}.
  \item \lib{MySQL Java Connector 5.1.34} - Comunicação com o banco de dados \est{MySQL}.
  \item \lib{Hibernate JPA Support 4.3.8 Final} - Adaptador do \est{Hibernate} para padrões \est{Java Persistence API}.
  \item \lib{Hibernate Validator Engine 5.1.3 Final} - Biblioteca para validar dados de entidades.
  \item \lib{Hibernate c3p0 Integration 4.3.8} - Gerenciador de conexões com o banco de dados.
\end{itemize}

Os detalhes sobre as funcionalidades das bibliotecas de comunicação com o banco de dados e mapeamento objeto/relacional são abordados no capítulo 6. 

Para fazer com que o \est{Gradle} adquira as bibliotecas necessárias e suas dependências, a seção \est{"dependencies"} do arquivo \arquivo{build.gradle} é alterada como mostra o quadro~\ref{lst:3}.

\groovycode{code/gradledependencies.txt}{Adicionando dependências ao projeto}{lst:3}

Com o arquivo \arquivo{build.gradle} alterado e salvo, o comando para baixar as dependências para o projeto está localizado no menu de contexto do projeto (clicando com o botão direito do \est{mouse} sobre ele) no caminho \est{Gradle/Refresh Dependencies}, que pode ser observado na Figura~\ref{fig:15}. O \est{Gradle} irá adquirir todas as bibliotecas especificadas no arquivo \arquivo{build.gradle} e suas dependências automaticamente. O \est{Spring MVC}, por exemplo, depende do \est{Spring Core} para funcionar e o \est{Hibernate JPA Support} precisa do \est{Hibernate Core}. Todas as dependências do projeto ficam visíveis na seção \est{Libraries/Gradle Dependencies}.

\figura{refreshdependencies.png}{Atualizando dependências de um projeto \est{Gradle}}{fig:15}

\subsubsection{Configurando a aplicação \est{web}}

Existem duas maneiras de se configurar uma aplicação \lang{Java}, usando arquivos \lang{XML} ou escrevendo a configuração em \lang{Java}. Nos exemplos dessa seção, é usada a segunda opção.

Os arquivos de configuração são armazenados no pacote \pacote{br.uece.webCrud.config}. Dentro desse pacote são criadas duas classes, \classe{AppInitializer} e \classe{SpringMvcConfig}, como mostra a Figura~\ref{fig:16}. 

\figura{configpackage.png}{Estrutura do projeto \spring com pacote para arquivos de configuração}{fig:16}

A primeira configuração que deve ser feita é usar a classe \classe{DispatcherServlet} como o \est{servlet} padrão e configurar o contexto da aplicação (configurações especificas do \est{Spring Framework}). \est{Servlets} são classes \lang{Java} que processam requisições para aplicação, elas podem servir páginas para o usuário, retornar objetos \sigla{JSON}, redirecionar requisições para outros \est{servlets}, ETC. Para mais informações sobre \est{servlets} recomenda-se o livro \est{Murach’s Java Servlets and JSP}.

A classe \classe{AppInitializer} herda da interface \classe{WebApplicationInitializer}. Para inicializar a aplicação, o \est{Spring Framework} irá procura classes que herdam dessa \est{interface} dentro dos pacotes. O conteúdo da classe deve estar como no quadro~\ref{lst:4}.

A interface \classe{WebApplicationInitializer} possui a assinatura de apenas um método, \metodo{onStartup}. Na implementação desse método é escrito código para configurar tanto o contexto da aplicação quando o \est{servlet} primário.

Primeiro é criado um objeto do tipo \classe{AnnotationConfigWebApplicationContext} e é usado o seu método \metodo{register} para adicionar a classe \classe{SpringMvcConfig} como uma classe de configuração do \est{Spring}. A classe \classe{AnnotationConfigWebApplicationContext} habilita o uso de anotações \lang{Java} para configurar demais classes, o conteúdo da classe \classe{SpringMvcConfig} é exposto mais adiante.

É criado então um \est{servlet} do tipo \classe{DispatcherServlet} que recebe o contexto como parâmetro e é usada a classe \classe{ServletRegistration} para registrar o \est{servlet} à aplicação. O método \metodo{addMapping} recebe como parâmetro o caractere "/", isso quer dizer que esse \est{servlet} é usado para todas a páginas \est{web} e demais caminhos dentro da aplicação. O método \metodo{setLoadOnStartup} recebe como parâmetro o valor 1, para configurar o \est{servlet} como o primeiro que o servidor deve usar.

\javacode{code/AppInitializer.txt}{Classe \classe{AppInitializer}}{lst:4}

Vários objetos que fazem parte da estrutura da aplicação (também conhecidos como \est{Spring Beans}) são configurados na classe \classe{SpringMvcConfig}, como mostra o quadro~\ref{lst:mvcconfig}. A anotação \annotation{@Bean} do \est{Spring Framework} decora métodos na classe \classe{SpringMvcConfig} que retornam objetos que são usados no núcleo da aplicação e definem seu contexto.

A classe \classe{SpringMvcConfig} começa decorada com as seguintes anotações:

\begin{itemize}
  \item \annotation{@Configuration} - Define a classe como uma classe de configuração do \est{Spring Framework}.
  \item \annotation{@EnableWebMvc} - Habilita o \est{Spring MVC}.
  \item \annotation{@EnableTransactionManagement} - Habilita o controle automático de transações com o banco de dados pelo \est{Spring Framework}.
  \item \annotation{@ComponentScan} - Configura os nomes de pacotes onde o \est{Spring IoC Container} deve procurar classes decoradas a anotação \annotation{@Component} e suas especializações, como \annotation{@Repository}, \annotation{@Service} e \annotation{@Controller} (Mais detalhes sobre essas anotações em capítulos posteriores).  
\end{itemize}

\javacode{code/mvcconfig.txt}{Classe \classe{SpringMvcConfig}}{lst:mvcconfig}

A classe começa definindo várias propriedades que são usadas para a criação da conexão com o banco de dados, como o \est{driver} a ser utilizado, localização, nome do banco, usuário e senha. Outras propriedades armazenam configurações do \sigla{JPA} (implementadas pelo \est{Hibernate}), como qual dialeto do \sigla{SQL} usar para gerar consultas no banco (dialeto do \est{MySql 5}), qual a ação executar na configuração \est{hibernate.hbm2ddl.auto} (\est{"create"} para criar o banco de dados e gerar tabelas a partir de classes decoradas com a anotação \annotation{@Entity}) e qual o esquema padrão a ser usado nas consultas (normalmente o mesmo nome do banco de dados no \est{MySql})

A classe \classe{SpringMvcConfig} herda da classe \classe{WebMvcConfigurerAdapter} para ter acesso a alguns métodos que facilitam a configuração da aplicação. Esses métodos decorados com \annotation{@Override} configuram o uso do \classe{ServletHandler} padrão do \est{Spring} e como a aplicação deve servir diferentes tipos de conteúdo ao usuário.

Os dois primeiros métodos decorados com \annotation{@Bean} retornam objetos com informações de onde e como encontrar as \est{views} da aplicação. O \classe{InternalResourceViewResolver} armazena configurações sobre em que diretório estão as \est{views} (\est{WEB-INF}) e suas extensões (\est{.jsp}). Assim é dito ao \est{Spring Framework} para procurar páginas \est{.jsp} dentro do caminho \arquivo{/WebContent/WEB-INF}.

O Segundo método configura o \classe{ContentNegotiatorViewResolver}, uma classe de uso interno do \est{Spring} que resolve \est{views} baseadas no cabeçalho das requisições \sigla{HTTP}. Note que ele recebe uma coleção de \classe{ViewResolvers} como parâmetro e é adicionado o \classe{InternalResourceViewResolver} do método anterior nessa lista.

Os três últimos métodos decorados com a anotação \annotation{@Bean} retornam objetos relacionados ao uso do banco de dados e manipulação de entidades. O primeiro deles retorna um objeto do tipo \classe{ComboPooledDatasource} que recebe vários parâmetros para se conectar ao banco de dados e servir como fonte de dados para a aplicação. 

O segundo método cria um objeto do tipo \classe{LocalContainerEntityManagerFactoryBean} que gerenciará a criação de uma implementação da interface \classe{EntityManager}. Implementações de \classe{EntityManager} são usadas nos repositórios para persistir objetos e consultar o banco de dados. Entre os parâmetros que o \classe{LocalContainerEntityManagerFactoryBean} recebe estão um adaptador para o uso do \est{Hibernate}, o nome do pacote onde são criadas entidades e o \classe{ComboPooledDatasource} configurado anteriormente para ser usado como fonte de dados. Ele também recebe um objeto do tipo \classe{Properties} contendo várias configurações do \est{Java Persistence API} (\sigla{JPA}). Para informações mais detalhadas sobre o \sigla{JPA}, recomenda-se o livro \est{Pro JPA 2.0}, 2ª edição, da editora \est{Appress}.

O último método retorna um objeto \classe{JpaTansactionManager}. Esse objeto é o responsável por gerenciar as transações com o banco de dados. Ele recebe a instancia do objeto \classe{LocalContainerEntityManagerFactoryBean} configurado anteriormente como parâmetro.

\subsection{Criando um projeto \anmvc no \est{Visual Studio Community 2013}}

O link \est{"new project..."}, na tela inicial do Visual \est{Studio Community 2013}, mostra um menu com diversos modelos para criação de projetos. Para o projeto desse trabalho, é usando o \est{"ASP.NET Web Application"} o menu \est{"Visual C\#"}.

Um projeto no \est{Visual Studio} faz parte de uma solução. Uma solução além de ser uma coleção de projetos, contém informações de dependências e configurações. A Figura~\ref{fig:17} ilustra a criação de um novo projeto. Os arquivos de solução junto com os de projeto são os equivalentes aos arquivos de projeto do \est{Eclipse} e o arquivo \arquivo{build.gradle}. vsnewproject.png

\figura{vsnewproject.png}{Criando um novo projeto no \est{Visual Studio Community 2013}}{fig:17}

O nome da solução de exemplo é \est{"NetWebCrud"}. O \est{Visual Studio} automaticamente dá o mesmo nome da solução para o primeiro projeto criado. O local de armazenamento dos arquivos também pode ser configurado nessa tela. Clicando no botão "OK", aparecerá o menu mostrado na Figura~\ref{fig:18}.

\figura{vsnewproject2.png}{Opções de um novo projeto \est{web} no \est{Visual Studio}}{fig:18}

Existem várias opções de projetos para \est{web}. Para um projeto \sigla{MVC} contendo apenas o mínimo necessário para seu funcionamento, é escolhido o modelo \est{"Empty"} e é marcada a opção \sigla{MVC}. O serviço \est{Microsoft Azure} não é utilizado, então a opção \est{"Host in the Cloud"} é desmarcada. Clicando em "OK", o \est{Visual Studio} irá gerar um projeto com a estrutura mostrada pela Figura~\ref{fig:19}.

\figura{19.png}{Estrutura de um projeto \anmvc}{fig:19}

O \anmvc funciona seguindo o princípio de convenção à configuração. O desenvolvedor deve seguir várias convenções para o desenvolvimento de sua aplicação, em compensação, a quantidade de configuração necessária é mínima.

Todas as páginas, e subpastas que contém páginas, devem ficar inseridas na pasta \est{Views}, todos os \est{controllers} devem fica na pasta \est{Controllers}. No \sigla{ASP.NET MVC} existe o conceito de \est{Areas}, onde o desenvolvedor pode organizar melhor seu código, mas esse conceito não é abordado nesse trabalho. A pasta \est{Models} pode conter entidades de negócio, repositórios e quaisquer outras classes da camada \est{Model} do padrão \sigla{MVC}, mas o desenvolvedor também pode criar tais classes em outros projetos dentro da solução.

A classe \classe{AssembyInfo} contém informações como nome da aplicação, empresa desenvolvedora e número de versão. Esse arquivo pode ser editado pelo desenvolvedor para atualizar os metadados da aplicação. A pasta \est{References}, contém as bibliotecas que são usadas no projeto. A pasta \est{App\_Data} pode conter um arquivo de banco de dados minimalista para armazenar dados, mas como é usado o banco de dados \est{MySql}, essa pasta é apagada manualmente.

A pasta \est{App\_Start} existe para que o desenvolvedor possa armazenar arquivos de inicialização da aplicação. Um modelo de um novo projeto \anmvc vêm com a classe \classe{RouteConfig} onde a tabela de rotas que mapeia \sigla{URLs} para \est{controllers} é configurada. Esse conteúdo desse arquivo é explicado no próximo capítulo durante a criação de \est{controllers}.

O arquivo \arquivo{Global.asax} contém o método \metodo{Application\_Start}. Esse método é chamado uma vez quando a aplicação é iniciada e nele podem ser incluídas linhas de código que serão executadas quando a aplicação iniciar. No modelo de projeto escolhido, ele já vem com uma chamada ao método \metodo{RegisterRoutes} da classe \classe{RouteConfig} e \metodo{RegisterAllAreas} da classe \classe{AreaRegstration}.

O Arquivo \arquivo{Web.config} na pasta raiz do projeto é um arquivo \lang{XML} que contém diversas configurações para o projeto. O arquivo \arquivo{web.config} na pasta \est{Views} contém configuração apenas para a criação de \est{views}.

\subsubsection{Adicionando dependências usando o \est{NuGet}}

Do mesmo modo que o \est{Gradle} pode adicionar bibliotecas externas ao projeto \lang{Java}, o \est{NuGet} é uma ferramenta que adiciona e gerencia pacotes nos projetos do Visual Studio. Nesse projeto de exemplo são usadas as seguintes bibliotecas:

\begin{itemize}
  \item \lib{MySql.Data.Entity 6.9.5} - Biblioteca necessária para o \est{MySql} funcionar com o \est{Entity Framework 6}. Adicionando essa biblioteca, o \est{NuGet} também adiciona o \est{driver do MySql} e o \est{Entity Framework 6} ao projeto.
  \item \lib{Ninject MVC5 3.2.2} - Injeção de dependências para projetos \anmvc. 
\end{itemize}

O console do \est{NuGet} pode ser acessado no menu \est{TOOLS/NuGet Package Manager/Package Manager Console}, como mostra a Figura~\ref{fig:20}.

\figura{20.png}{Acessando o console do \est{NuGet}}{fig:20}

O console do \est{NuGet} é exibido no \est{Visual Studio} como mostra a Figura~\ref{fig:21}. Nele o desenvolvedor pode digitar comandos para procurar e adquirir bibliotecas para seus projetos.

\figura{21.png}{Console do NuGet}{fig:21}

Para instalar as bibliotecas citadas anteriormente, executa-se os seguintes comandos no console do \est{NuGet}:

\begin{itemize}
  \item \est{Install-package mysql.data.entity}
  \item \est{Install-package ninject.mvc5}
\end{itemize}

Quando o \est{NuGet} terminar de baixar todos os arquivos, eles são adicionado ao projeto. A Figura~\ref{fig:22} ilustra a instalação das bibliotecas.

\figura{22.png}{Console do \est{NuGet}}{fig:22}

Ao terminar a instalação, os arquivos \arquivo{packages.config} e \arquivo{Web.config} são atualizados com as referências e configurações das novas bibliotecas.

A instalação do \est{Ninject Mvc 5} adiciona o arquivo \arquivo{NinJectWebCommon.cs} à pasta \est{App\_Start}. Na Figura~\ref{fig:23} pode-se observar o arquivo adicional citado. O conteúdo e funcionalidade desse arquivo é abordado no capitulo 5.

\figura{23.png}{Arquivo adicional do \est{Ninject}}{fig:23}

\subsubsection{Adicionando informações de conexão com o banco de dados}

O acesso ao banco de dados é configurado no arquivo \arquivo{Web.config} na raiz do projeto. Para adicionar informações de conexão com o banco \est{MySql}, é adicionada a \est{tag} \est{connectionStrings} como no exemplo mostrado no quadro~\ref{lst:6}.

\xmlcode{code/6.txt}{Adicionando configurações de conexão ao \arquivo{Web.xml}}{lst:6}

A \est{tag} \est{configuration} é a raiz do arquivo de configuração. A \est{tag} \est{configSections} deve ser a primeira filha da \est{tag} raiz, caso não seja, a aplicação irá reportar um erro de configuração. Note que já existem referências ao \est{Entity Framework}. A \est{tag} \est{connectionStrings} deve ser filha da \est{tag} \est{configuration}.

A \est{tag} \est{add} é usada para adicionar informações de conexão com o banco de dados. É necessário dar um nome para a conexão, configurar a \est{connection string} propriamente dita e o nome da classe responsável pelo acesso ao banco. A \est{connection string} deve conter no mínimo informações sobre para qual servidor apontar, qual o nome do banco de dados e usuário/senha utilizados. 

\subsection{Conclusão}

Criar um novo projeto com o \est{Spring MVC} requer escrita de código, mais passos e conhecimento de como o \est{framework} funciona internamente. A vantagem de um projeto com \est{Spring} é a questão da modularidade de componentes (o desenvolvedor adiciona ao projeto somente aquilo que precisa) e uma liberdade maior de configuração.

Uma maneira de tornar a configuração inicial de projetos \lang{Java} com \est{Spring} mais simples é usar o módulo \est{Spring Boot}. O \est{Spring Boot} configura automaticamente a aplicação a partir dos arquivos \est{.jar} contidos no projeto. Ele detecta as bibliotecas populares e "adivinha" como o projeto deve ser configurado. Internamente ele cria de forma automática a configuração que foi demonstrada na seção 2.1.3.

As vantagens de criação de um novo projeto \est{ASP.NET MVC} no \est{Visual Studio} são os modelos de projetos que já vem prontos logo após a instalação. Não existe a necessidade de realizar tantas configurações iniciais, contudo menos aspectos do projeto são configuráveis. O desenvolvedor deve obedecer as convenções do \est{ASP.NET MVC}.

No próximo capitulo será mostrado como criar \est{controllers} e \est{views} nos dois tipos de projetos.

\newpage
\section{Criando controllers e views}

Um controller é uma classe que  recebe requisições, processa informações (ou chama outras classes processa-las) e devolve um resultado ao usuário. Resultados comuns são páginas da web e objetos JSON ou XML para processamento no navegador (usando Javascript). Views, no contexto de uma aplicação web, são as próprias páginas que serão exibidas ao usuário.

Nesse capitulo será demonstrado como criar controllers e views em ambos os ambientes de desenvolvimento. Serão expostos exemplos de como criar controllers com ações que retornam páginas, objetos JSON e serão mostrados exemplos de ações que aceitam parâmetros. Serão dados também exemplos de como usar as view engines que geram páginas HTML dinamicamente.

\subsection{Criando um controller com uma ação que retorna uma página}

Uma das funções mais comuns dos controllers é retornar páginas para o usuário. Nas próximas seções será criado um controller simples que irá retornar uma página estática para exibição no navegador.

Numa aplicação MVC, um controller nunca deve instanciar nem usar métodos de outro controller. Se o desenvolvedor achar que isso é necessário, é prudente considerar criar uma classe de serviços (ou classe de negócios) para encapsular tal funcionalidade. Controllers devem apenas receber requisições, se for o caso chamar outras classes para processar requisições, e no fim devolver o resultado ao usuário. O capitulo 5 abordará a criação de classes de serviço.

Os exemplos desse capítulo, irão manipular uma classe chamada Person. Os quadros~\ref{lst:7} e~\ref{lst:8} mostram o código das classes em Java e C\#.

\javacode{code/7.txt}{Classe Person em Java}{lst:7}

A anotação @DateTimeFormat especifica em qual formado o capo de data será escrito. A escolha desse formato será explicada na seção 4.1.2.

\sharpcode{code/8.txt}{Classe Person em C\#}{lst:8}

\subsubsection{Java}

Controllers no Spring MVC são classes decoradas com a anotação @Controller. Essas classes podem estar contidas em qualquer pacote do projeto. No projeto exemplo, elas estarão contidas no pacote br.uece.webCrud.controller. O código contido no quadro~\ref{lst:9} mostra um exemplo de um controller, com o nome de PersonController e com uma ação que retorna uma página.

\javacode{code/9.txt}{PersonController no projeto Spring}{lst:9}

A anotação @RequestMapping configura com qual o caminho, a partir da raiz da aplicação, as ações do controller serão acessadas. A mesma anotação em uma ação configura qual o caminho para acessa-la a partir do caminho do controller. Por exemplo, para acessar a ação addPage o usuário entraria com o endereço <raiz da aplicação>/person/add. É possível não usar o @RequestMapping no controller e usá-lo apenas na ação, mas fazendo isso o caminho para a ação será em relação à raiz da aplicação. Também é possível configurar para qual método HTTP a ação irá responder. No exemplo acima, a ação é executada apenas para requisições usando o método GET.

No Spring MVC uma das maneiras de retornar uma página para o usuário é retornar um objeto String com o caminho do arquivo da página. Lembrando que na seção 3.1.3 foram configurados um prefixo e um sufixo no objeto InternalResourceViewResolver, e na seção 2.1 o Gradle foi configurado com o nome da pasta onde ficará armazenado o conteúdo especifico da web. Então o caminho completo para o arquivo que será retornado é <raiz do projeto>/WebContent/WEB-INF/person/add.jsp.

Agora será criada a página que essa primeira ação irá retornar. É criada uma pasta chamada person dentro de WEB-INF, e dentro dessa pasta é criado o arquivo add.jsp, como pode ser visto na Figura~\ref{fig:24}.

\figura{24.png}{Primeira view adicionada ao projeto Java}{fig:24}

O conteúdo do arquivo add.jsp é editado como no exemplo do quadro~\ref{lst:10}.

\jspcode{code/10.txt}{Arquivo add.jsp}{lst:10}

A diretiva page no cabeçalho da página diz ao servidor como tratar o arquivo, no caso como uma página HTML. O resto arquivo é um formulário HTML comum, que recebe dois valores (o nome e a data de nascimento de uma pessoa) e tem um botão que os envia para o servidor. Note que o formulário faz o envio usando o método POST.

\subsubsection{ASP.NET MVC}

Um controller é adicionado ao projeto ASP.NET MVC clicando com o botão direito do mouse na pasta Controllers, em seguida selecionado as opções “Add” e “Controller”. A Figura~\ref{fig:25} ilustra a adição do controller.

\figura{25.png}{Adicionando um controller no Visual Studio}{fig:25}

Irão aparecer diversas opções de modelos de controllers, a opção a opção usada é a “MVC 5 Controller – Empty” e o controller foi também nomeado como PersonController. Uma das convenções do ASP.NET MVC é que controllers sempre tem que terminar com a palavra “Controller”. Normalmente é recomendado que se nomeie controllers com o nome da entidade que eles manipulam como prefixo, para facilitar a organização do código.

Também será adicionada uma ação chamada Add que irá retornar uma página. O código do controller deverá ficar como no quadro~\ref{lst:11}. Note que PersonController é subclasse da classe Controller.

\sharpcode{code/11.txt}{PersonController em C\#}{lst:11}

A ação Add retorna um objeto do tipo ActionResult, que é uma classe pai de vários tipos de resultados no ASP.NET MVC como JSONResult e ViewResult. O método View retorna um ViewResult, que é uma página web. A ação Add também está decorada com anotação HttpGet, logo essa ação irá responder apenas ao método GET.

No ASP.NET MVC, o mapeamento de endereço para controllers e ações é centralizado pela tabela de rotas, não por anotações isoladas em cada controller e método. Quem configura a tabela de rotas é a classe RouteConfig, mostrada no quadro~\ref{lst:12}.

\sharpcode{code/12.txt}{A classe RouteConfig}{lst:12}

A configuração da tabela de rotas começa ignorando qualquer requisição a arquivos com extensão .axd, que são arquivos de recursos do ASP.NET. Logo em seguida é configurada a rota padrão. O padrão {controller}/{action}/{id} determina que o acesso às ações devem seguir o caminho <raiz da aplicação>/<nome do controller>/<nome da ação>/<parâmetro opcional chamado “id”>. Logo para acessar a ação Add de PersonController o caminho é <raiz da aplicação>/person/add. Note que não é necessário digitar personController no caminho, apenas o prefixo é necessário. A rota padrão vem configurada com o intuito de apontar para uma ação chamada Index de um controller chamado HomeController se apenas o endereço da raiz da aplicação for requisitado, o desenvolvedor pode mudar esses valores. 

Para adicionar uma view, se clica com o botão direito do mouse em uma ação e então na opção “Add View...” como mostrado na Figura~\ref{fig:26}. 

\figura{26.png}{Adicionando uma View no ASP.NET MVC}{fig:26}

Outra convenção do ASP.NET MVC é que views devem ter o nome das ações que as retornam e ficar dentro de uma pasta com o nome do controller, como na Figura~\ref{fig:27}. Será usado o modelo “Empty” na criação dessa primeira view. A extensão de arquivos de views em projetos ASP.NET MVC 5 é cshtml.

\figura{27.png}{View adicionada ao projeto ASP.NET MVC}{fig:27}

A pasta Shared pode conter views acessíveis à todos os controllers. Em alguns modelos de projetos do Visual Studio ela contém um arquivo chamado \_Layout.cshtml. Esse arquivo é uma página modelo (ou layout) usada quando se quer aproveitar uma mesma estrutura para várias views diferentes. Essa pasta também pode armazenar Partial Views, que são pedaços de views e componentes que o desenvolvedor pode usar em diversas páginas. Layouts e Partial Views não serão abordados nesse trabalho.

O conteúdo do arquivo Add.cshtml é aditado para que fique igual ao exemplo do quadro~\ref{lst:13}.

\razorcode{code/13.txt}{O arquivo Add.cshtml}{lst:13}

Tanto no projeto Java/Spring como no projeto ASP.NET MVC, quando acessada pelo Google Chrome, a view irá aparece como na Figura~\ref{fig:28}. 

\figura{28.png}{View adicionada ao projeto ASP.NET MVC}{fig:28}

\subsection{Criando ações parametrizadas}

Na seção 4.1, foram criadas ações que respondem ao método HTTP GET e retornam uma página ao usuário. Nessa seção essa página será utilizada para enviar informações ao servidor utilizando o método HTTP POST. Na views de exemplo, o atributo action não está definido nos formulários, então ele vai enviar informações ao servidor para o mesmo caminho usado para acessá-lo (<raiz da aplicação>/person/add).

Devem ser criadas ações no controller que respondam ao mesmo endereço da página, mas usem método POST. Essas ações também deverão receber as informações que o formulário irá enviar. Isso é feito configurando anotações e adicionando parâmetros às ações em ambos os projetos. Nos exemplos das seções 4.2.1 e 4.2.2 serão feitas ações que receberão um objeto do tipo Person e o adicionarão à uma coleção armazenada em memória.

\subsubsection{Java}

O código presente no quadro~\ref{lst:14} é adicionado à classe PersonController:

\javacode{code/14.txt}{Ação de PersonController no projeto Java que responde ao método POST}{lst:14}

A anotação @RequestMapping no método addPost aponta para o mesmo caminho que o método addPage mas ela responde às chamadas usando o método POST. O método addPost recebe como parâmetro um objeto do tipo Person. Os parâmetros de métodos também podem ser decorados com anotações.

A anotação @ModelAttribute permite que o Spring MVC procure e mapeie valores do cabeçalho HTTP para o objeto person. No quadro~\ref{lst:10}, o atributo name dos elementos input onde são digitadas as informações de um novo objeto são “name” e “birthDate”, os mesmos nomes dos atributos da classe Person.

A Figura~\ref{fig:29} mostra as ferramentas de desenvolvedor do Google Chrome com um exemplo do que acontece quando se envia os dados da página ao servidor.

\figura{29.png}{Enviando dados para o servidor}{fig:29}

No quadro~\ref{lst:7}, o atributo birthDate da classe Person foi decorado com a anotação @DateTimeFormat para que aceitasse o formato de data “yyyy-MM-dd”, a Figura~\ref{fig:29} mostra que esse é o formato de data que o Google Chrome envia para o servidor. Se o formato de data não estivesse configurado ou fosse enviado outro padrão, o servidor enviaria uma reposta de erro 400 (Bad Request).

Quando chegam ao servidor, os dados são mapeados automaticamente para o parâmetro person do método addPost como mostrado na Figura~\ref{fig:30}, e a partir daí o desenvolvedor trabalhar com os dados.

\figura{30.png}{Objeto person com parâmetros corretamente populados no projeto Java}{fig:30}

O retorno do método addPost redireciona a requisição para outra ação que mostrará uma página com uma tabela com todas pessoas adicionadas à lista. As implementações dessa ação e página serão demonstradas mais adiante.

\subsubsection{ASP.NET MVC}

O código apresentado no quadro~\ref{lst:15} foi adicionado ao PersonController.

\sharpcode{code/15.txt}{PersonController do projeto ASP.NET com nova ação}{lst:15}

O ASP.NET MVC não guarda o estado de objetos entre requisições, então a lista deverá ser guardada como uma variável da aplicação. Armazenada dessa forma, o estado da lista se preservará e ficará disponível para todos os usuários. Lembrando que em capítulos posteriores, a lista será substituída por serviços que persistem as entidades no bando de dados.

Por convenção do ASP.NET MVC, a ação do controller que reponde ao método POST deve ter o mesmo nome da view a qual ele responde.  A única configuração necessária é decorar a ação com a anotação HttpPost. O ASP.NET MVC vai fazer o mapeamento dos dados para o objeto person de forma semelhante ao Spring MVC, só que não é necessário especificar o formato do campo birthDate. A Figura~\ref{fig:31} mostra o resultado do mapeamento.

\figura{31.png}{Objeto person no ASP.NET MVC corretamente populado}{fig:31}

Assim como no projeto Java/Spring, o objeto person é adicionado em uma lista e a ação redireciona o usuário para uma página que mostra todos os objetos da lista.

\subsection{Retornando um objeto JSON}

Aplicações web modernas utilizam a técnica AJAX para atualizar partes de páginas em vez de enviar uma requisição para que o servidor envie uma página completa novamente. Essa técnica é essencial para dar ao usuário uma melhor experiência de uso da aplicação. Os dados são enviados e recebidos assincronamente utilizando código Javascript. Esses dados podem estar no formato XML ou JSON, nessa seção será demonstrado como retornar dados no formato JSON. Como exemplo será retornado um único objeto do tipo Person para o usuário.

Para mais informações sobre como manipular dados com Javascript e Ajax, é recomendada a leitura dos livros Pro Javascript For Web Apps e Pro jQuery da editora Apress.

\subsubsection{Java}

A biblioteca Jackson Databind é responsável por serializar objetos Java no formato JSON. Essa biblioteca foi adicionada ao projeto durante a configuração do arquivo build.gradle na seção 3.1.2. 

Para uma ação retornar um objeto JSON, ela deve retornar um objeto Java decorado com a anotação @ResponseBody, como no código do quadro~\ref{lst:16}.

\javacode{code/16.txt}{Ação no Spring MVC que retorna um objeto JSON}{lst:16}

Acessando a ação getOne pelo navegador, é obtida a resposta exposta na Figura~\ref{fig:32}.

\figura{32.png}{Resultado JSON no projeto Java}{fig:32}

O atributo birthDate é enviado ao navegador como um número que pode ser usado para criar um objeto Date do Javascript.

\subsubsection{ASP.NET MVC}

O ASP.NET MVC pode trabalhar com objetos no formato JSON sem precisar de uma biblioteca de terceiros. O exemplo do quadro~\ref{lst:17} mostra uma ação que retorna um objeto JSON.

\sharpcode{code/17.txt}{Ação no ASP.NET MVC que retorna um objeto JSON}{lst:17}

O método estático Json no final da ação faz a conversão de objetos para o formato JSON. Por padrão o ASP.NET MVC só envia objetos JSON usando o método HTTP POST, para a habilitar o uso de HTTP GET é necessário um parâmetro adicional. A Figura~\ref{fig:33} mostra a resposta à ação GetOne.

\figura{33.png}{Resultado JSON no projeto ASP.NET MVC}{fig:33}

Aqui existe uma inconveniência. O modo como o ASP.NET envia datas faz com que seja necessário mais código Javascript para extrair o número que realmente representa a data e criar um objeto Date.

\subsection{Gerando Views Dinâmicas}

Nessa seção será demonstrado como fazer uma página que exibe todos os itens das listas de objetos Person em ambos os projetos. Serão feitas ações que enviam as listas para as views e irão montar o código HTML usando as view engines padrão de cada tecnologia, JSTL no projeto Java/Spring e Razor no projeto ASP.NET MVC.

\subsubsection{Java (JSTL)}

Observe o método listPage na classe PersonController no exemplo do quadro~\ref{lst:18}.

\javacode{code/18.txt}{Ação no projeto Java que retorna uma página com a lista de Persons}{lst:18}

O tipo de retorno do método listPage e um objeto do tipo ModelAndView. Esse objeto representa uma página dinâmica que pode conter e manipular objetos Java. O método é mapeado para o endereço <raiz da aplicação>/person/list. 

A ação começa com a verificação de existência, e se for o caso criação da lista. Logo em seguida ele cria um objeto ModelAndView que aponta para uma nova página que será criada dentro da pasta person, list.jsp. O método addObject adiciona a lista persons para que a página possa utilizá-la com o nome de referencias personsList. O Resultado então é retornado para o usuário. O quadro~\ref{lst:19} mostra o código da página list.jsp.

\jspcode{code/19.txt}{Código da página list.jsp}{lst:19}

A página começa com o cabeçalho padrão de páginas jsp. Logo abaixo, o cabeçalho taglib adiciona a referência à biblioteca JSTL básica. Essa biblioteca contém um conjunto de tags JSTL, pedaços de código Java que ajudam a montar páginas dinâmicas. As tags JSTL são escritas na página como pedaços de código que lembram tags HTML, mas devem começar utilizando prefixo configurado no cabeçalho taglib (no caso do exemplo acima, a letra “c”). Até o fim da tag HTML <thead>, o que está escrito na página é apenas HTML puro. A parte onde o JSTL entra em ação é dentro do corpo da tabela. 

A tag forEach cria um pedaço de bloco HTML para cada item em uma coleção. Essa coleção é configurada no atributo items e usando a sintaxe do JSTL é dito que a coleção se chama personList, o mesmo nome que foi usado como referencias para passar a lista de objetos Person para a página. O atributo var configura um nome de referência para o objeto que que será usado em cada iteração da lista.

Dentro de cada iteração é criada uma nova linha para a tabela, e em cada linha é criada duas colunas, uma mostrando o atributo name e outra o birthDate do objeto person. Note que não é necessário chamar os métodos getName e getBirthDate, é necessário apenas referenciar o nome do atributo que o desenvolvedor deseja mostrar na página. Depois de adicionar alguns objetos à lista, é obtido o resultado exposto na Figura~\ref{fig:34}.

\figura{34.png}{Resultado da página list.jsp}{fig:34}

O JSTL possui muitas outras taglibs. Para mais informações, consulte a documentação do JSTL.

\subsubsection{ASP.NET (Razor)}

O exemplo do quadro~\ref{lst:20} mostra a ação que retorna a página que exibe o conteúdo da lista.

\sharpcode{code/20.txt}{Ação que retorna a página list.cshtml}{lst:20}

O método View pode receber como parâmetro qualquer objeto que o desenvolvedor queira passar para a página, aqui ele recebe a lista de objetos do tipo Person. O quadro~\ref{lst:21} mostra o código fonte da página list.cshtml.

\sharpcode{code/21.txt}{Código fonte da página list.cshtml}{lst:21}

Além da sintaxe da view engine Razor (que mistura código C\# com HTML) uma diferença em relação à página do projeto Java é que uma página no ASP.NET MVC pode ser fortemente tipada.

A primeira linha da página importa o namespace NetWebCrud.Models para se utilizar de suas classes. A segunda linha informa qual é o tipo de objeto que será o modelo da página, uma lista de objetos Person como a que foi passada na ação do controller.

O objeto Model dentro do laço foreach é a referência ao objeto que foi enviado para a página. Model pode fazer referência a qualquer tipo de objeto e a diretiva @model no começo da página especifica seu tipo para que os recursos de auto completar do Visual Studio estejam disponíveis e o ASP.NET MVC possa gerar a página. O resultado pode ser visto na Figura~\ref{fig:35}.

\figura{35.png}{Resultado da página list.cshtml}{fig:35}

Note que o ASP.NET MVC exibe também a hora do atributo BirthDate.

\subsection{Conclusão}

Enquanto no Spring MVC o desenvolvedor deve decorar seus controllers e ações com várias anotações @RequestMapping, no ASP.NET MVC o mapeamento de endereços é centralizado inteiramente na tabela de rotas. Isso junto com as convenções do ASP.NET MVC ajudam o desenvolvedor a escrever menos código.

Os controllers no Spring MVC podem ser qualquer classe decorada com a anotação @Controller, no ASP.NET MVC devem ser classes que herdem da superclasse Controller e tenham o sufixo Controller no seu nome. O modo de criação de controllers no Spring MVC é mais flexível, mas é uma boa prática também adicionar o sufixo Controller em tais classes e deixa-las em um pacote especifico para controllers objetivando uma melhor organização de código.

Ao enviar dados para o servidor, a única diferença significativa é o modo de enviar datas. O mapeamento dos dados da requisição HTTP para objetos é simples e funcional em ambas as tecnologias.

O ASP.NET MVC dá suporte nativo para manipulação de objetos no formato JSON, bastando apenas que o desenvolvedor utilize o método Jaon para gerar um objeto JSONResult. O Spring MVC não vem com suporte nativo para trabalhar com objeto JSON, sendo necessária a biblioteca Jackson Databind e a configuração de anotações.

A view engine JSTL utiliza uma sintaxe parecida com o HTML, se integrando melhor ao código da página, enquanto o Razor tem a vantagem da possibilidade de ser fortemente tipado e utilizar as vantagens do C\# como a função de auto completar código do Visual Studio. Em ambas as tecnologias o desenvolvedor pode estender as view engines, em projetos Java novas taglibs podem ser criadas e no ASP.NET MVC podem ser feitas View Helpers e Partial Views. Um vantagem do ASP.NET MVC em relação ao Java Enterprise Endition em se tratando de views é o suporte nativo à Layouts (também conhecidas como master pages). Caso o desenvolvedor Java queria usar Layouts, deve recorrer às bibliotecas de terceiros como o Sitemesh ou utilizar outras view engines como o FreeMarker. E aqui encontramos a maior vantagem do Java Enterprise Edition em relação à views, o desenvolvedor pode escolher simplesmente utilizar outras view engines.

No próximo capitulo serão abordados a criação de classes de negócio/serviços e injeção de dependências. 

\newpage
\section{Classes de serviços e injeção de dependências}

Uma aplicação de três camadas típica se divide em camadas de apresentação, negócios/serviços e persistência de dados. A camada de serviços é onde se escreve o código que representa regras de negócio das aplicações, enquanto a camada de persistência é responsável por guardar os dados da aplicação para uso posterior. É importante que essas camadas estejam fracamente acopladas, pois o desenvolvedor pode, por exemplo, aproveitar as classes de negócio que ele escreveu para uma aplicação \est{web} em uma aplicação para celular.

Nos exemplos desse trabalho, a camada de apresentação é formada pelas páginas \est{web} escritas no capítulo anterior, os \est{controllers} funcionam como uma ponte entre a camada de apresentação e de negócios. \est{Controllers} devem apenas receber e responder requisições, o ideal é que não exista código de regras de negócios em suas ações.

Nesse capítulo é demonstrado como escrever classes de serviço (também chamadas de classes de negócio) fracamente acopladas à camada de apresentação e aos \est{controllers}. 

\subsection{Classes de serviços}

É criada como exemplo uma classe de serviço em cada projeto que contêm um método com uma regra de negócio simples. As listas de objetos \classe{Person}, até agora pertencente aos \est{controllers}, são movidas para essas classes como uma forma de representar a camada de persistência. Em ambos os projetos, o serviço implementa uma \est{interface}. Diferente do que é sugerido para \est{controllers}, que um \est{controller} não deve chamar métodos de outro, classes de serviço podem utilizar outras classes de serviço.

\subsubsection{Java}

No projeto \lang{Java}, a \est{interface} e classe concreta são criadas no pacote \pacote{br.uece.webCrud.service}. Primeiro é feita a interface \classe{PersonService} que o serviço irá implementar, como podemos observar no quadro~\ref{lst:22}.

\javacode{code/22.txt}{\est{Interface} \classe{PersonService}}{lst:22}

No quadro~\ref{lst:23} pode-se observar o serviço \classe{PersonServiceImpl} implementando a \est{interface} \classe{PersonService}.

\javacode{code/23.txt}{Classe \classe{PersonServiceImpl}}{lst:23}

A classe \classe{PersonServiceImpl} começa decorada com a anotação \annotation{@Service}. Essa anotação é usada pelo \est{Spring Framework} para marcar classes da camada de serviços. A anotação \annotation{@Service} herda da anotação \annotation{@Component}, então essa é uma classe que pode ser usada pelo \est{Spring IoC Container} durante injeção de dependências. Mais detalhes sobre injeção de dependências e o modo como o \est{Spring} injeta uma instância dessa classe serão explicados nas seções 5.2 e 5.2.1. Segundo a documentação do \est{Spring Framework 4.1.4}, a anotação \annotation{@Service} tem o mesmo efeito que \annotation{@Component}, mas é recomendado o uso de \annotation{@Service} pois em versões futuras do \est{framework}, essa anotação poderá conter funcionalidades adicionais.

O construtor de \classe{PersonServiceImpl} inicializa a lista de objetos \classe{Person}. O método \metodo{add} recebe um objeto do tipo \classe{Person} como parâmetro. Ele verifica se já existe um objeto com o mesmo nome na lista, se sim, dispara uma exceção, se não, adiciona o objeto à lista. Essa verificação é um exemplo simples de uma regra de negócios.

\subsubsection{.NET}

As classes de serviços no projeto \est{ASP.NET MVC} são criadas dentro da pasta \arquivo{Models/Services}. Para o \est{ASP.NET MVC} a camada \est{model} de uma aplicação \sigla{MVC} contém tanto entidades quanto regras de negócios. Assim como no projeto \lang{Java}, primeiro é feita a \est{interface} \classe{IPersonService} mostrada no quadro~\ref{lst:24}.

\sharpcode{code/24.txt}{\est{Interface} \classe{IPersonService}}{lst:24}

O quadro~\ref{lst:25} mostra a implementação da \est{interface} pela classe \classe{PersonService}.

\sharpcode{code/25.txt}{Classe \classe{PersonService}}{lst:25}

A classe \classe{PersonService} no projeto \est{ASP.NET MVC} é uma classe comum para onde foi movida a lista de objetos \classe{Person} e contém um método idêntico ao do projeto \lang{Java}. Nenhuma anotação ou configuração especial é feita na classe para identificá-la como serviço.

\subsection{Injeção de dependências}

Injeção de dependências é uma técnica utilizada para diminuir o acoplamento entre classes. Nos exemplos dessa seção, as classes de serviço são injetadas nos \est{controllers} criados no capitulo anterior. 

Considere o exemplo do quadro~\ref{lst:26}.

\javacode{code/26.txt}{Exemplo de classes fortemente acopladas}{lst:26}

No exemplo acima, a classe \classe{Foo} usa uma classe chamada \classe{BarImpl} que implementa uma \est{interface} chamada \classe{Bar}. Nesse exemplo a classe \classe{Foo} fica fortemente acoplada à implementação \classe{BarImpl}. Imagine se a classe \classe{BarImpl} fosse uma classe de persistência que salva informações em arquivos de texto e um dia o desenvolvedor precisasse portar a aplicação para mais um ambiente onde seria usado um banco de dados. Sem usar injeção de dependências, o desenvolvedor também teria que escrever uma nova versão da classe \classe{Foo} que usasse outra implementação de \classe{Bar}.

O exemplo do quadro~\ref{lst:27} mostra como funciona a injeção de dependências.

\javacode{code/27.txt}{Exemplo de classes fracamente acopladas}{lst:27}

No exemplo acima, a classe \classe{Foo} agora recebe em seu construtor um abjeto que implemente \classe{Bar}. Uma instância de \classe{BarImpl} é criada dentro do método \metodo{main} e injetada dentro da instância de \classe{Foo}. Nesse cenário, as classes não estão tão acopladas e o desenvolvedor pode usar outras implementações de \classe{Bar} mais facilmente. A injeção de dependências também é conhecida como inversão de controle (\est{Inversion of Control} ou \sigla{IoC}), pois dá a responsabilidade de inicializar dependências de uma classe para classes externas. 

Essa técnica ainda pode ser melhorada se a injeção de dependências for automatizada, requerendo menos código. É isso que o \est{IoC Container} do \est{Spring Framework} e o \est{Ninject} fazem. O uso dessas ferramentas será demonstrado nas seções seguintes.

\subsubsection{Java}

O \est{Spring IoC container} resolve dependências procurando por classes para serem injetadas dentro dos pacotes da aplicação de modo automático. Na seção 3.1.3., a classe de configuração \classe{SpringMvcConfig} foi decorada com a anotação \annotation{@ComponentScan}. Os nomes dos pacotes passados como parâmetro para essa anotação são os pacotes onde o \est{Spring Framework} procura por classes para serem instanciadas e injetadas.

Para serem utilizadas pelo \est{Spring IoC container}, as classes devem estar decoradas com a anotação \annotation{@Component} ou alguma de suas especializações, como \annotation{@Service}, \annotation{@Repository} e \annotation{@Controller} ou métodos decorados com a anotação \annotation{@Bean}. Por padrão o \est{Spring IoC container} injeta as classes como \est{singletons}, criando apenas uma instância da classe para ser usada várias vezes. Esse comportamento pode ser alterado pela anotação \annotation{@Scope} nas classes que se deseja injetar.

A diferença entre as anotações \annotation{@Component} e \annotation{@Bean} (também utilizada na seção 3.1.3) é que \annotation{@Component} é usado em classes que o próprio \est{Spring IoC container} procura e instancia enquanto \annotation{@Bean} é usado em métodos que retornam objetos que o próprio desenvolvedor criou. Classes anotadas com \annotation{@Component} ou uma de suas especializações devem ter um construtor que não receba parâmetros.

O código do quadro~\ref{lst:28} mostra uma nova versão do \est{controller} \classe{PersonController} do projeto \est{Java/Spring}, agora com uma instância de \classe{PersonServiceImpl} sendo injetada e utilizada.

\javacode{code/28.txt}{\classe{PersonController} utilizando \classe{PersonService} no projeto \est{Java/Spring}}{lst:28}

No lugar da lista em memória, agora o \est{controller} possui e utiliza um \classe{PersonService} que  está decorado com a anotação \annotation{@Autowired}. Essa anotação marca propriedades onde o \est{Spring IoC container} deve injetar dependências. No caso acima, o \est{container} procura por classes decoradas com \annotation{@Component} ou suas especializações, que implementam \classe{PersonService} e estão contidas nos pacotes configurados por \annotation{@ComponentScan}. Encontrada a classe \classe{PersonServiceImpl}, uma instância dessa classe é criada e atribuída à propriedade \est{personService} para uso no \classe{PersonController}.

Essa não é a única maneira de injetar dependências usando o \est{Spring}. Para conhecer mais opções de injeção de dependências, aconselha-se consultar sua documentação.

\subsubsection{.NET}

O \est{ASP.NET MVC 5} não possui injeção de dependências automática nativa, então é usado a biblioteca \est{Ninject} para essa funcionalidade. Diferente do \est{Spring}, o \est{Ninject} não procura por classes de modo automático para injetar dependências, as classes que o desenvolvedor deseja injetar devem ser configuradas por código. Na seção 3.2.1, o \est{Ninject MVC 5} foi adicionado ao projeto e uma classe chamada \classe{NinjectWebCommon} (exibida no quadro~\ref{lst:29}) foi criada na pasta \arquivo{App\_Start}. 

\sharpcode{code/29.txt}{Classe \classe{NinjectWebCommon}}{lst:29}

O método \metodo{Start} é executado quando a aplicação é inicializada, ele registra módulos do \est{Ninjet} para uso interno da aplicação, cria e inicializa um \est{kernel} do \est{Ninject}. O \est{kernel} é o objeto onde é feita a configuração de injeções de dependência, essa configuração é feita no método \metodo{RegisterServices} como mostra o quadro~\ref{lst:30}.

\sharpcode{code/30.txt}{Registro de dependências no \est{Ninject}}{lst:30}

O \est{kernel} do \est{Ninject} pode usar uma sintaxe fluente para configurar dependências. Aqui usa-se o método genérico \metodo{Bind} recebendo a interface \classe{IPersonService} seguido do método \metodo{To} configurando a classe \classe{PersonService} para ser a classe concreta injetada quando o \est{Ninject} encontra aquela interface. Por último, o método \metodo{InRequestScope} cria uma instancia de \classe{PersonService} para cada requisição do usuário ao servidor. Existe o método \metodo{InSingletonScope} que pode criar apenas uma instancia da classe para todos os usuários e todas as requisições, mas a necessidade de se utilizar \metodo{InRequestScope} é abordada na seção 6.3.2.

O \est{Ninject} é uma biblioteca extensa que contém módulos que funcionam em vários tipos de projetos \sigla{.NET}. Para mais informações aconselha-se acessar a página do \est{Ninject} (\url{http://www.ninject.org/}).

O \est{controller} \classe{PersonController} é modificado para utilizar o serviço \classe{PersonService}, como pode ser observado no quadro ~\ref{lst:31}.

\sharpcode{code/31.txt}{\classe{PersonController} do projeto \est{ASP.NET MVC} usando \classe{PersonService}}{lst:31}

A anotação \annotation{Inject} decora a propriedade \classe{PersonService} onde é injetada a instância de classe \classe{PersonService}, do mesmo modo que \annotation{@Autowired} no projeto \est{Java/Spring}. A propriedade deve ter um método \metodo{set} público para que o \est{Ninject} possa ter acesso e injetar a classe concreta, o método \metodo{get} pode ser mais restrito.

\subsection{Conclusão}

O \est{Spring} possui a anotação \annotation{@Service} para marcar classes de serviço e classes de negócio, enquanto no \est{ASP.NET MVC} qualquer classe pode ser uma classe de serviço. Atualmente nenhuma das tecnologias mostra vantagem na criação de serviços mas no futuro, talvez sejam adicionadas funcionalidades para a anotação \annotation{@Service} que possam beneficiar o \est{Spring Framework}.

O \est{Spring} é superior ao \est{ASP.NET MVC 5} em se tratando de injeção de dependências. Além de ter um \est{IoC container} nativo, o \est{Spring} resolve dependências automaticamente enquanto o \est{ASP.NET MVC 5} precisa de bibliotecas de terceiros, e o \est{Ninject} precisa de configurações via código para todas as classes que são injetadas.

Na próxima versão do \sigla{ASP.NET}, também chamada de \est{vNext}, será adicionado um \est{IoC Container} nativo. Até o momento em que este trabalho está sendo escrito, o \est{vNext} está em fase de testes público e pode passar por mudanças, então o uso do \est{IoC Container} da próxima versão não foi considerado.

No próximo capítulo é abordada a criação do banco de dados a partir de entidades de negócio e acesso a dados usando repositórios do \est{Spring} e a classe \classe{DbContext} do \est{Entity Framework}.

\newpage
\section{Entidades e repositórios}

Entidades são classes que representam os objetos de negócio, a classe Person utilizada até agora é um exemplo de entidade. Em ambos os projetos, essa classe será usada para gerar uma tabela no banco de dados e substituir as listas em memória que foram usadas até então. Essa técnica é chamada de mapeamento objeto/relacional, pois mapeia propriedades de objetos para tabelas e colunas no banco de dados relacional. Nos exemplos desse capitulo serão usados o Hibernate no projeto Java/Spring e o Entity Framework no projeto ASP.NET MVC como bibliotecas para mapeamento objeto/relacional.

Além de a classe Person, nesse capitulo será criada a classe Contact que conterá o e-mail e o telefone de uma pessoa. Essa classe terá um relacionamento de um para um com a classe Person e irá gerar uma chave estrangeira no banco de dados.

Com as entidades prontas, serão feitos repositórios para persistir as entidades no banco de dados. Será feito um repositório genérico e um repositório especifico para cada classe.

\subsection{Entidades}

As seções a seguir irão mostrar como utilizar uma classe para gerar tabelas no banco de dados. Entidades precisam de um identificador único para ser sua chave primária no banco de dados, essa propriedade será chamada Id e será do tipo inteiro.

Como serão usadas duas entidades nesse capitulo e ambas precisam do identificador único, será criada uma classe base com essa propriedade em comum chamada BaseEntity. O intuito da criação dessa classe é mostrar como é possível o uso de herança nas entidades. As classes Person e Contact irão ser especializações de BaseEntity.

\subsubsection{Java}

Entidades no projeto Java/Spring são criadas no pacote br.uece.webCrud.model. A classe BaseEntity é criada como mostra o quadro~\ref{lst:32}.

\javacode{code/32.txt}{Classe BaseEntity no projeto Java}{lst:32}

A classe BaseEntity é decorada com a anotação @MappedSuperclass que diz ao Hibernate que entidades que sejam suas subclasses devem levar em consideração as propriedades herdadas no mapeamento objeto/relacional. A propriedade id é decorada com as anotações @Id, que configura o Hibernate para usá-la como chave primária e única, e @GeneratedValue, que delega ao banco de dados a lógica de geração do valor da chave.

A classe Person então é modificada como no quadro~\ref{lst:33}.

\javacode{code/33.txt}{Classe Person herda de BaseEntity}{lst:33}

A classe Person agora é subclasse de BaseEntity e está decorada com a anotação @Entity. A anotação @Entity diz ao Hibernate que essa classe deve ser mapeada para uma tabela e as propriedades da classe para as colunas da tabela.

Por padrão o Hibernate procura por uma tabela com o mesmo nome da classe e colunas com o mesmo nome das propriedades para realizar o mapeamento, mas esse comportamento pode ser modificado com as anotações @Table, @Column, @Transient e muitas outras. A propriedade name por exemplo, está decorada com a anotação @Column especificando que aquela propriedade não pode ser nula no banco de dados e a propriedade birthDate está decorada com a anotação @Temporal especificando que a coluna no banco deve ser do tipo Date.

Na seção 3.1.3, durante a configuração do projeto, a propriedade hibernate.hbm2ddl.auto foi configurada com o valor “create”, assim o Hibernate irá criar as tabelas no banco de dados de acordo com as configurações de classes decoradas com a anotação @Entity. Outros valores para essa configuração podem ser “update”, para atualizar a estrutura das tabelas sem perder dados, e “validate”, para apenas verificar se o mapeamento objeto/relacional está consistente. O Hibernate cria tabelas, mas não cria o banco de dados, para que a criação de tabelas funcione é necessário que o banco de dados já exista. O Hibernate cria as tabelas no momento em que a aplicação é iniciada.

\subsubsection{.NET}

Entidades no projeto ASP.NET MVC são criadas na pasta Model/Entities. Considere que a classe Person é movida para essa pasta. O quadro~\ref{lst:34} mostra a classe BaseEntity do projeto ASP.NET MVC.

\javacode{code/34.txt}{Classe BaseEntity no projeto ASP.NET}{lst:34}

Uma convenção do Entity Framework é que se uma classe tiver uma propriedade chamada Id de tipo numérico ou guid (tipo de identificar único), essa propriedade será usada como chave primária. Assim nenhuma configuração adicional é necessária.

Assim como no projeto Java, a classe Person do projeto ASP.NET MVC é modificada para ser subclasse de BaseEntity, como mostrado no quadro~\ref{lst:35}.

\javacode{code/35.txt}{Classe Person no projeto ASP.NET agora herda de BaseEntity}{lst:35}

Assim como no projeto Java, entidades do Entity Framework podem ser decoradas com anotações que controlam como as tabelas serão geradas. No exemplo acima a anotação Required também diz que a coluna correspondente à propriedade Name não pode aceitar valores nulos.

\paragraph{Criando o contexto do banco de dados}

Não existe configuração na classe acima que indique que ela é uma entidade e que deve ser usada no mapeamento objeto/relacional. Esse papel é da classe DbContext do Entity Framework. A classe DbContext representa o banco de dados como um todo. Para criar o banco de dados a partir das entidades, o desenvolvedor deve criar uma classe que herde de DbContext e tenha propriedades do tipo DbSet como a classe NetWebCrudContext no exemplo do quadro~\ref{lst:36}. 

\sharpcode{code/36.txt}{Classe NetWebCrudContext representa o contexto do banco de dados}{lst:36}

A classe NetWebCrudContext possui um DbSet de objetos do tipo Person que representa a tabela que será gerada no banco de dados. Para utilizar o banco, o desenvolvedor deve criar uma instância do contexto e fazer consultas aos DbSets usando LINQ (Language Integrated Query). O LINQ é uma linguagem para realizar consultas em coleções do .NET Framework. Usado em DbSets, ele gera consultas SQL automaticamente para manipular o banco de dados. Consultas com LINQ serão abordadas na seção 6.4.

O construtor de NetWebCrudContext executa o construtor de DbContext recebendo como parâmetro o nome da connection string que contém informações de conexão com o banco. Ele recebe o nome da connection string NetWebCrudContext, a mesma que foi configurada no arquivo Web.xml na seção 3.2.2.

O construtor do contexto do banco de dados também é usado para configurar o tipo de inicialização do banco. O construtor de NetWebCrudContext utiliza como inicializador a classe DropCreateDatabaseIfModelChanges, então se qualquer entidade for modificada, o banco de dados será totalmente reconstruído e todos os dados perdidos. Existem outras classes que podem ser usadas como inicializadores como CreateDatabaseIfNotExists, para criar o banco apenas uma vez, e DropCreateDatabaseAways para sempre recriar o banco de dados quando a aplicação iniciar. O desenvolvedor pode estender esses inicializadores ou construir um completamente novo que implemente a interface IDatabaseInitializer.

O Entity Framework não atualiza automaticamente a estrutura do banco de dados sem perder informações, para isso é necessário utilizar o Entity Framework Migrations. Essa funcionalidade permite utilizar as linguagens C\# ou VB.NET para executar scripts no banco de dados e atualizar sua estrutura. O Entity Framework Migrations não é abordado nesse trabalho, para mais informações recomenda-se consultar a documentação do Entity Framework.

O método OnModelCreating é usado para configurar diversos aspectos da criação do banco de dados.  No exemplo do quadro~\ref{lst:36}, a convenção de pluralizar o nome das tabelas é removida.

Diferente do Hibernate que cria ou atualiza o banco de dados quando a aplicação é iniciada, o Entity Framework cria o banco de dados na primeira vez em que o contexto do Entity Framework é instanciado.

Uma instancia de NetWebCrudContext precisa ser instanciada para que se possa usar o banco de dados. No projeto exemplo, cada requisição de um usuário deve criar uma nova instancia de NetWebCrudContext. Se mais de um usuário utilizar a mesma instancia, poderão haver erros de concorrência e um usuário poderá ter acesso os dados de outro que ainda não foram salvos para o banco de dados. O Ninject será responsável por criar as instancias de NetWebCrudContext e injeta-las nos repositórios que serão criados na seção 6.3.2. O quadro~\ref{lst:37} mostra a configuração de injeção de NetWebCrudContext.

\sharpcode{code/37.txt}{Injeção do contexto do banco de dados}{lst:37}

\subsection{Relacionamentos entre entidades}

Entidades podem se relacionar com outras com o uso de chaves estrangeiras no banco de dados. O relacionamento entre a classe Person e a classe Contact, que guardará o e-mail e telefone de uma pessoa, será usado nos exemplos dessa seção.

\subsubsection{Java}

A classe Contact é criada no pacote br.uece.webCrud.model como mostra o quadro~\ref{lst:38}.

\javacode{code/38.txt}{Classe Contact no projeto Java}{lst:38}

Assim como a classe Person, a classe Contact herda de BaseEntity e é decorada com a anotação @Entity. O Relacionamento com a classe Person é configurado pela anotação @OneToOne decorando o atributo person. O atributo mappedBy recebendo o valor “contact” quer dizer que na classe Person deve existir um atributo com esse nome, configurado como o dono do relacionamento entre as tabelas. Resumindo, a tabela correspondente à classe Person terá a coluna com a chave estrangeira para Contact.

Além da anotação @OneToOne, o JPA possui as anotações @OneToMany, @ManyToOne e @ManyToMany para criar relacionamentos. As anotações @OneToMany e @ManyToMany devem ser usadas em uma coleção de objetos, quando uma entidade tem um relacionamento de “um para muitos” ou de “muitos para muitos” com outra entidade.

O relacionamento na classe Person também deve ser configurado como mostra o quadro~\ref{lst:39}.

\javacode{code/39.txt}{Classe Person com relacionamento para Contact}{lst:39}

A classe Person agora possui uma propriedade do tipo Contact, também decorada com a anotação @OneToOne e com a anotação @JoinColumn. A primeira anotação é configurada para cascatear todas as operações de Person para Contact. Se por exemplo, um objeto do tipo Person for atualizado no banco de dados, a sua propriedade contact também será atualizada. A configuração fetch recebe como valor FetchType.EAGER, configurando a propriedade contact para ser recuperada do banco de dados por eager loading (executando uma única consulta). A propriedade fetch também pode receber FetchType.LAZY, fazendo com que contact só seja carregado quando necessário, mas gerando uma nova consulta ao banco de dados.

A anotação @JoinColumn configura a classe Person para criar a coluna da chave estrangeira na sua tabela correspondente, essa coluna tem o nome de contactId. O Hibernate detecta automaticamente as chaves decoradas com @Id e as utiliza como chaves estrangeiras em tabelas relacionadas. A Figura~\ref{fig:36} mostra o resultado de criação das tabelas no banco de dados MySQL. 

\figura{36.png}{Tabelas geradas pelo Hibernate}{fig:36}

\subsubsection{.NET}

A classe Contact, ilustrada no quadro~\ref{lst:40}, também é criada no projeto ASP.NET MVC.

\sharpcode{code/40.txt}{Classe Contact no projeto ASP.NET MVC}{lst:40}

A classe Contact não requer nenhuma configuração, sendo apenas preciso herdar de BaseEntity para adquirir a propriedade Id. Por outro lado, a classe Person recebe mais propriedades como mostra o quadro~\ref{lst:41}.

\sharpcode{code/41.txt}{Classe Person no projeto ASP.NET com novas propriedades}{lst:41}

Na classe Person é adicionada uma propriedade Contact modificada com a palavra chave “virtual” para configurá-la como uma propriedade de navegação. O desenvolvedor pode acessar as informações de Contact por lazy loading acessando essa propriedade.  Isso resulta em mais uma consulta no banco, mas com o uso do LINQ é possível recuperar as informações de Person e Contact com apenas uma consulta.

A propriedade ContactId gera a coluna da chave estrangeira. Por convenção do Entity Framework, propriedades de chaves estrangeiras devem ter o nome da propriedade de navegação (Contact) seguido do nome da sua chave primária (Id).

Por último, é necessário adicionar um DbSet para Contact no contexto do banco de dados, como mostra o quadro~\ref{lst:42}.

\sharpcode{code/42.txt}{Classe NetWebCrudContext com o DbSet para Contact}{lst:42}

O resultado no banco é semelhante ao do projeto Java/Spring, como mostra a Figura~\ref{fig:37}. Uma diferença que deve ser ressaltada é a criação da tabela \_\_migrationhistory. Essa tabela é usada pelo Entity Framework para armazenar dados sobre o histórico da estrutura do banco de dados. Assim o Entity Framework Migrations sabe quais modificações devem ser feitas no banco quando as entidades são modificadas.

\figura{37.png}{Tabelas geradas pelo Entity Framework}{fig:37}

\subsection{Repositórios}

A persistência e acesso aos dados serão feitos utilizando o padrão de repositórios. Em cada projeto será criado um repositório genérico, que poderá realizar operações básicas (salvar, atualizar, recuperar e apagar) para qualquer classe que seja subclasse de BaseEntity. Um repositório especifico para a entidade Person é criado nos dois projetos e outro para Contact apenas no projeto ASP.NET MVC. Eles serão especializações do repositório genérico e possuirão operações especificas para essas entidades.

Será demonstrado como utilizar a Java Persistence Query Language (JPQL) e a Language Integrated Query (LINQ) para realizar consultas ao banco de dados e como gerenciar transações. Por último, os repositórios serão injetados nas classes de serviço, substituindo as listas em memória.

\subsubsection{Java}

Nos exemplos dessa seção, os repositórios e interfaces que eles implementam no projeto Java/Spring serão criados no pacote br.uece.webCrud.repositories.

Primeiramente, são criadas a interface GenericRepository e a classe GenericRepositoryImpl, demonstradas nos quadros~\ref{lst:43} e~\ref{lst:44} respectivamente. Essa classe é o repositório genérico mencionado anteriormente.

\javacode{code/43.txt}{Interface GenericRepository}{lst:43}

\javacode{code/44.txt}{Classe GenericRepositoryImpl}{lst:44}

A classe GenericRepositoryImpl é decorada com a anotação @Repository, então instâncias dela podem ser injetadas Spring IoC Container. Erros de seus métodos em tempo de execução, dispararam a exceção DataAccessException do Spring Framework.

Essa classe faz uso de Java Generics, podendo realizar suas operações com qualquer classe que herde de BaseEntity. Seu construtor de extrai o tipo da classe ele está trabalhando a utiliza em suas operações. GenericRepositoryImpl é uma classe abstrata (que não pode ser instanciada) logo, quem efetivamente poderá executar suas operações serão os repositórios que herdarão dessa classe.

O objeto da classe que executa as operações no banco de dados é do tipo EntityManager, decorado com a anotação @PersistenceContext. A instancia de EntityManager é criada pelo bean LocalContainerEntitityManagerFactoryBean, configurado na seção 3.1.3, e injetado pelo Spring IoC Container. Para objetos de acesso a dados, a anotação @PersistenceContext funciona do mesmo modo que @Autowired.

O método getAll retorna todas as entradas de uma determinada entidade armazenada no banco de dados. Ele mostra um exemplo de como criar uma consulta usando o método createQuery de EntityManager, recebendo o texto da consulta escrito em JPQL. Essa linguagem possui similaridades com SQL. O método getResultList executa a consulta criada, convertendo o texto JPQL em SQL, realizando a consulta no banco de dados, mapeando tuplas para objetos, e devolvendo o resultado como uma lista. Para mais informações sobre o JPQL, é recomendado consultar a documentação da linguagem no site \url{http://docs.oracle.com/cd/E15523_01/apirefs.1111/e13946/ejb3_langref.html}.

O método findById usa o método find do EntityManager para encontrar uma entidade com chave primária e do tipo que foram passados como parâmetros. O método add chama o método persists para inserir um novo objeto no banco de dados. Esse objeto não pode ter uma chave primária de valor já existente no banco, ou o Hibernate irá disparar uma exceção PersistenceException.

O método merge, chamado por update, realiza atualização dos valores de uma entidade no banco de dados. Para que ele funcione é necessário que a chave primária do objeto a ser atualizado exista, ou o Hibernate também disparará uma exceção. O método delete, usa getById para recuperar uma entidade pela sua chave primária e chama o método remove de EntityManager para remove-la do banco de dados.

Com o repositório genérico criado, é possível criar um repositório especifico para a classe Person, como mostram os quadros~\ref{lst:45} e~\ref{lst:46}. A classe PersonRepositoryImpl adiciona o método existsWithName, que verifica a existência de uma entidade com um dado nome no banco de dados. Nesse método é criada uma consulta mais complexa, que retorna o valor booleano true, se existir uma entidade no banco de dados com a propriedade name igual a passada como parâmetro e propriedade id diferente da passada como parâmetro. Esse exemplo também mostra como adicionar parâmetros às consultas, utilizando método setParameter.

\javacode{code/45.txt}{Interface PersonRepository}{lst:45}

\javacode{code/46.txt}{Classe PersonRepositoryImpl}{lst:46}

Por último, a lista em memória da classe PersonServiceImpl é substituída por PersonRepository e a anotação @Transactional é adicionada à classe, como mostra o quadro~\ref{lst:47}.

\javacode{code/47.txt}{PersonServiceImpl fazendo uso de PersonRepository}{lst:47}

A anotação @Transactional do Spring Framework pode ser utilizada em classes ou métodos. Essa anotação configura o gerenciamento de transações com o banco de dados. Decorando um método, essa anotação faz com que uma única transação seja usada em todas as operações de acesso a dados dentro daquele método. Decorando uma classe, como no exemplo do quadro~\ref{lst:47}, a anotação aplica o seu efeito a todos os métodos da classe.  O Spring controla internamente a criação e utilização de transações já existentes usando o Bean JpaTransactionManager também configurado na seção 3.1.3. Se um método decorado com essa anotação for chamado internamente por outro também decorado com ela, o método interno irá aproveitar a transação que já existe e não irá criar uma nova. Esse comportamento padrão pode ser modificado configurando atributos da anotação. 

Caso não ocorram erros nas operações com o banco de dados, as operações da transação são persistidas de forma atômica. Caso haja algum erro, as operações são revertidas e uma exceção é disparada. De toda forma, a transação é destruída automaticamente quando não é mais utilizada.

Como o relacionamento de Person com Contact configurado com CascadeType.ALL na seção 6.2.1, quando um objeto do tipo Person é salvo ou atualizado no banco de dados, o seu contato também é. Então nos exemplos desse capitulo para Java, não houve a necessidade de se criar um repositório para a classe Contact.

\subsection{.NET}

Os repositórios no projeto ASP.NET MVC são criados na pasta Models/Repositories. Assim como no projeto Java/Spring, começa-se criando o repositório genérico e sua interface. O quadro~\ref{lst:48} mostra a interface do repositório genérico, IGenericRepository, e o quadro~\ref{lst:49} mostra sua implementação, GenericRepository.

\sharpcode{code/48.txt}{Interface IGenericRepository}{lst:48}

\sharpcode{code/49.txt}{Classe GenericRepository}{lst:49}

Assim como no projeto Java/Spring, o repositório genérico é uma classe abstrata que realiza operações no banco de dados para classes que herdam de BaseEntity. Também semelhante ao outro projeto, existe uma propriedade no repositório que efetivamente irá persistir dados e consultar o banco, a propriedade context do tipo NetWebCrudContext. A propriedade EntitySet é usada para facilitar o acesso ao DbSet correto da entidade a qual o repositório genérico irá manipular.

O método getById mostra um exemplo de como se usar expressões lambda e a sintaxe fluente do LINQ para realizar uma consulta. Métodos de filtragem e ordenação da sintaxe fluente do LINQ retornam coleções do tipo IQueryable, essa interface permite que mais métodos sejam chamados em cascata para a criação de consultas complexas. Uma consulta do LINQ só é realmente executada no bando de dados quando se chamam certo métodos, como Single, First, ToList e ToArray, e essas consultas também são transformadas em scripts SQL quando são executadas no banco de dados. No método getAll, o método ToList do DbSet retorna todas as tuplas do banco de dados transformadas em uma lista de objetos.

Dentro do método save, um objeto é adicionado ao DbSet usando o método Add, equivalente a uma operação de inserção na tabela. Operações de inserção, atualização e deleção de dados só são persistidas após a chamada do método SaveChanges do contexto. Esse método cria uma transação que em caso de erro reverte a transação e dispara uma exceção. É possível ter um controle melhor sobre transações, como ainda será visto nessa seção.

O método update é um pouco mais complexo. Para persistir novos dados de uma entidade no banco de dados, caso a entidade não esteja anexada ao contexto, é necessário anexa-la e utilizar o contexto para modificar seu estado para Modfied. Assim, quando SaveChanges for chamado, o contexto saberá que aquela entidade é de um objeto que já existe no banco de dados (através da chave primária já existente) e irá atualizar suas informações.

O método Delete é bastante similar ao do repositório do projeto Java/Spring. Uma entidade é recuperada pela sua chave primária e o método Remove do DbSet a remove do banco de dados.

O método GetTransaction proporciona um melhor controle sobre transações. O controle automático de transações que o Entity Framework possui no método SaveChanges pode não ser suficiente para conversações extensas com o banco de dados em regras de negócio complexas. Então é possível criar uma transação manualmente, com o método BeginTransation, e utilizar essa transação para persistir ou reverter alterações. Mesmo com o uso dessa transação, e necessário chamar o método SaveChanges antes executar a persistência de dados.

Os repositórios para as entidades Person e Contact são criados como mostram os quadros~\ref{lst:50} e ~\ref{lst:51}. O Entity Framework cascateia automaticamente operações de inserção e deleção entre entidades relacionadas, mas não de atualização. Sendo assim, é necessária a existência de repositório de Contact para que atualizações dessa entidade sejam persistidas.

\sharpcode{code/50.txt}{Interfaces IPersonRepository e IContactRepository}{lst:50}

\sharpcode{code/51.txt}{Classes PersonRepository e ContactRepository}{lst:51}

Assim como no projeto Java/Spring, o repositório para a classe Person possui um método que verifica a existência de uma outra entidade que possua o mesmo nome. A consulta é feita com uma expressão lambda do LINQ. O repositório para Contact não possui nenhuma operação adicional, usa apenas as operações herdades de GenericRepository. Como esses repositórios também serão injetados na classe de serviço PersonService, sua configuração de injeção é adicionada à classe NinjectWebCommon, como motra o quadro~\ref{lst:52}.

\sharpcode{code/52.txt}{Configuração de injeção de repositórios no projeto ASP.NET MVC}{lst:52}

Por último, a classe de serviço PersonService é atualizada como no quadro~\ref{lst:53}. O método Update mostra como fazer controle manual de transações. Chamando o método GetTransaction de PersonRepository, ou de qualquer outro repositório, uma transação é criada para o contexto NetWebCrudContext que é injetado no escopo da requisição do usuário. Dessa forma, só existe uma instância do contexto do banco de dados sendo utilizada por todos os repositórios, então a transação também é única.

Usando uma transação dessa forma, o desenvolvedor pode fazer as operações que desejar com quaisquer repositórios, e chamar o método Commit da transação para finalizar a persistência. Em caso de erros, é chamado o método Rollback para reverter às alterações no banco de dados. Como a transação está dentro do escopo da palavra chave using, o coletor de lixo do .NET Framework se encarrega de chamar o método Dispose automaticamente para finalizar a transação.

\sharpcode{code/53.txt}{Classe PersonService utilizando ambos os repositórios no projeto ASP.NET MVC}{lst:53}

\subsection{Conclusão}

A criação de entidades para o modelo objeto/relacional com Hibernate e Entity Framework possuem abordagens distintas. No primeiro, classes precisam de anotações para serem tratadas como entidades, e no segundo não há essa necessidade. No Entity Framework, classes mais simples podem ser usadas e convenções cuidam de lógica no mapeamento objeto/relacional. A desvantagem do uso do Entity Framework é a necessidade de criação de uma classe de contexto que representa o banco de dados. Dependendo da complexidade da aplicação, a codificação e manutenção da classe de contexto pode se tornar uma inconveniência.

O relacionamento entre entidades no Hibernate é feito com anotações na própria entidade, e a configuração de relacionamentos de muito para muitos, por exemplo, pode se tornar complicada de entender para um desenvolvedor iniciante. O Entity Framework abstrai essa configuração, sendo apenas necessária a criação de propriedades de navegação entre entidades e propriedades que representem chaves estrangeiras.

Repositórios em projetos Spring com Hibernate utilizam uma implementação de EntityManager para manipular entidades, podendo usar Criteria Queries ou JPQL para gerar consultas. Criteria Queries utilizam vários métodos para gerar uma consulta, que no fim resulta em código complexo, de baixa legibilidade e de manutenção questionável. A linguagem JPQL se assemelha a SQL e é mais legível, mas tem a desvantagem de ser escrita em Strings, o que a torna mais propensa a erros. Em projetos com o Entity Framework, a linguagem LINQ é usada para gerar consultas. Essa linguagem é de fácil entendimento, e pode utilizar as vantagens do IntelliSense (ferramenta de auto completar código do Visual Studio), tornando a detecção de erros mais fácil e a escrita de código mais eficiente.

Quanto ao controle de transações, o modo automático como o Spring Framework lida com transações o tornam uma melhor opção nesse aspecto do que o Entity Framework. 

\newpage
\section{Conclusão}

Nesse trabalho foi comparada a criação de uma aplicação web utilizando as tecnologias Java com o Spring MVC e o Hibernate, e o ASP.NET MVC utilizando C\#. Foram abordadas a configuração do ambiente de desenvolvimento, configuração inicial de projeto e a criação das três camadas da aplicação, apresentação (subdividida entre controllers e views), serviços (incluindo injeção de dependências) e persistência.

As conclusões a que se chegaram por esse trabalho em relação ao tópicos abordados foram as seguintes:

\begin{itemize}
  \item Preparação do ambiente de desenvolvimento - A tecnologia .NET é mais prática e poupa tempo do desenvolvedor. Enquanto com o .NET o necessário para a criação de um projeto se encontra pronto para uso em um único instalador, utilizando a tecnologia Java o desenvolvedor deve adquirir vários softwares de fontes diferentes e configura-los.
  \item Criação e configuração de um novo projeto - Aqui a tecnologia .NET também obteve vantagem. Os modelos de projeto ASP.NET MVC do Visual Studio e convenções adotadas, ajudam o desenvolvedor à escrever sua aplicação imediatamente. Com o Spring Framework é necessária configuração de diversos objetos da estrutura da aplicação.
  \item Criação de controllers - Na criação de controllers em si, nenhuma tecnologia mostrou grande superioridade. Mas o ASP.NET MVC demonstrou maior praticidade no mapeamento de endereços para ações, centralizando essa configuração em um único lugar e, vez de anotações espalhadas pelo código como no Spring Framework.
  \item Criação de views - A possibilidade de views fortemente tipadas e utilização de funcionalidades de auto completar código, deram vantagem à view engine Razor do ASP.NET MVC em relação ao JSTL do Java Enterprise Edition. Mas seria injusto não mencionar que a liberdade de escolher outras view engines é uma grande vantagem da plataforma Java.
  \item Criação de classes de serviço - Nenhuma tecnologia se mostrou superior à outra em relação a criação de classes de serviço.
  \item Configuração de injeção de dependências - A existência de um container nativo de injeção de dependências no Spring Framework, junto com configuração automática de instanciação e injeção de classes mostram superioridade dessa tecnologia em relação ao ASP.NET MVC nesse aspecto. Além de precisar adquirir uma biblioteca externa (o Ninject, utilizado como exemplo) também foi necessária configuração adicional para cada classe a ser injetada no projeto .NET.
  \item Criação de entidades - Pela não necessidade da criação de um contexto do banco de dados e possuir atualização da estrutura do banco de forma automática, o Hibernate implementando o JPA se mostrou superior ao Entity Framework, apesar de requerer que as entidades sejam decoradas com várias anotações.
  \item Criação de repositórios - A sintaxe fluente do LINQ (.NET) se mostrou superior ao JPQL (Java/JPA) por utilizar expressões lambda, ser fortemente tipada e fazer uso das funções de auto completar código do Visual Studio. Apesar disso, desenvolvedores mais familiarizados em trabalhar com scripts SQL podem preferir o JPQL. Em relação ao controle de transações, o Spring Framework se mostrou superior, pois automatiza a criação e reuso de transações ao mesmo tempo que dá ao desenvolvedor controle sobre elas. 
\end{itemize}

Existem outras carateristas inerentes às tecnologias utilizadas que devem ser lavadas em consideração na hora de escolher algum delas para um novo projeto. A versão atual do ASP.NET por exemplo, não funciona em sistemas operacionais que não sejam o Windows. Então se nos requisitos do sistema especificasse que ele deve rodar em Linux, por exemplo, Java deverá ser a escolha entre as duas tecnologias. A familiaridade da equipe de desenvolvimento e suas preferencias subjetivas também impactam na escolha da tecnologia.

De modo geral, a conclusão a que esse trabalho chega é que se um projeto precisar ficar pronto rápido e a equipe de desenvolvimento não tiver uma preferencia clara por uma tecnologia, o uso do ASP.NET pode ser uma boa opção. Em contra partida, se o time de desenvolvimento quiser ter controle granular sobre o projeto, dispor de tempo para testar várias arquiteturas diferentes e dominar o Spring Framework, utilizar o ambiente Java é uma melhor opção.

Como trabalho futuro, o desempenho das duas tecnologias pode ser analisado. Quando o ASP.NET MVC 6 for lançado, pode ser feita uma nova comparação para desenvolvimento em ambiente Linux. Pode-se também utilizar o Spring Boot em um trabalho futuro e verificar como ele auxilia a configuração de um projeto Java.

Esse trabalho foi importante para auxiliar a ter uma compreensão melhor das vantagens e desvantagens entre as duas tecnologias de modo mais lógico. Ouve-se muitas discussões entre desenvolvedores em momentos de descontração que dizem rpeferir uma tecnologia à outra por motivos subjetivos, muitos deles não conhecendo realmente a tecnologia rival. Assim, esse trabalho também auxilia desenvolvedores experientes em fundamentar seus elogios e críticas à uma ou outra tecnologia.

\end{document}