\documentclass[a4paper,12pt]{article}
\usepackage[brazilian]{babel}
\usepackage[section]{placeins}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{indentfirst} %Margem no primeiro paragrafo
\usepackage{hyperref} %Urls
\usepackage[left=3cm,top=3cm,right=2cm,bottom=2cm]{geometry}
\usepackage{graphicx} %figuras
\usepackage{helvet} %fonte arial
\usepackage{caption}
\usepackage{setspace}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{newfloat}
\usepackage{listings}
\usepackage{microtype}
\setlength{\parskip}{1em}
\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\lstlisting}{\arabic{lstlisting}}
\renewcommand{\lstlistingname}{Código}

\lstset{aboveskip=20pt,belowskip=20pt}

\newenvironment{simple}%
{\noindent}%
{\par\noindent}

\graphicspath{ {figuras/} }

\newcommand{\anmvc} {
\sigla{ASP.NET MVC} 5
}

\newcommand{\spring} {
\est{Java/Spring MVC}
}

\newcommand{\mysql} {
\est{MySQL}
}

\newcommand{\figura}[3] {
	\begin{figure}[ht]
		\centering
		\includegraphics{#1}
		\caption{#2}
		\label{#3}
	\end{figure}
	\FloatBarrier
}

\newcommand{\est}[1] {
\textit{#1}}

\newcommand{\classe}[1] {
\textit{#1}}

\newcommand{\arquivo}[1] {
\textit{#1}}

\newcommand{\sigla}[1] {
\textit{#1}}

\newcommand{\lang}[1] {
\textit{#1}}

\newcommand{\lib}[1] {
\textit{#1}} 

\newcommand{\annotation}[1] {
\textit{#1}}

\newcommand{\pacote}[1] {
\textit{#1}}

\newcommand{\metodo}[1] {
\textit{#1}}

\newcommand{\groovycode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=Java, label=#3]{#1}
}

\newcommand{\javacode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=Java,label=#3]{#1}
	%\FloatBarrier
}

\newcommand{\sharpcode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=C,label=#3]{#1}
	%\FloatBarrier
}

\newcommand{\xmlcode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=XML,label=#3]{#1}
	%\FloatBarrier
}

\newcommand{\jspcode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=HTML,label=#3]{#1}
	%\FloatBarrier
}

\newcommand{\razorcode}[3] {
	\lstinputlisting[showstringspaces=false, basicstyle=\footnotesize, captionpos=b, breaklines=true, caption=#2, language=HTML,label=#3]{#1}
	%\FloatBarrier
}

\begin{document}
\title{Comparação de desenvolvimento de aplicações web com ASP.NET MVC 5 e Spring MVC 4}
\author{José Rafael Vasconcelos Cavalcante}
\date{January 5, 2011}
\maketitle

\newpage
\section{Introdução}

\subsection{Objetivo}

Este trabalho tem como objetivo comparar a criação de uma aplicação utilizando duas tecnologias, \textit{Java} com o \lib{Spring Framework} e \lib{Hibernate}, e o \sigla{ASP.NET MVC 5} e \textit{Entity Framework} utilizando \lang{C\#}. é usado como exemplo, a criação de um projeto de uma aplicação web de três camadas (apresentação, serviços e persistência) que utiliza o padrão \est{Model View Controller} (\sigla{MVC}).

A abordagem utilizada consiste em dividir as tarefas necessárias para a criação da aplicação em cinco capítulos, e nesses capítulos serão demonstrados exemplos de código com as duas tecnologias. Depois de expostos os exemplos de como executar as tarefas, serão ressaltadas as vantagens, desvantagens e características distintas de cada tecnologia. As tarefas a serem executadas serão as seguintes:

\begin{itemize}
  \item Preparação do ambiente de desenvolvimento.
  \item Criação e configuração de um novo projeto.
  \item Criação de \est{controllers}.
  \item Criação de \est{views}.
  \item Criação de classes de serviço.
  \item Configuração de injeção de dependências.
  \item Criação de entidades.
  \item Criação de repositórios.
\end{itemize}

\subsection{Estado da arte}
 
No momento de criação desse trabalho, a literatura conta com vários trabalhos sobre medição de desempenho de aplicações \est{web} e poucos comparando como se cria uma aplicação. E mesmos trabalhos comparando o esforço do desenvolvimento de aplicações utilizando tecnologias diferentes, utilizam versões antigas de tais tecnologias. 

Atul Mishra em seu trabalho \est{"Critical Comparison Of PHP And ASP.NET For Web Development"}, por exemplo, compara a criação de um site utilizando uma versão antiga do \sigla{ASP.NET} e utilizando \sigla{PHP}. Nesse trabalho não são expostos exemplos de código, apenas as conclusões tiradas pelo autor. Mostafa Pordel e Faranhaz Yekeh, autores do artigo "\est{"JSF vs ASP.NET, what are their limits?"} também comparam o desenvolvimento de aplicações \est{web} utilizando as tecnologias \lang{Java} e \lib{.NET}. Mas também utilizam versões antigas de ambas as tecnologias e mostram poucos exemplos de código.

Tiago Bencardino, em seu trabalho de conclusão do curso de engenharia de teleinformática de titulo "\est{iQuizzer}: Integrando aplicações web e dispositivos móveis em um ambiente para criação e execução de \est{quizzes}", comparou o desenvolvimento de uma aplicação para as plataformas moveis \est{Android} e \est{iOS}. Bencardino utilizou uma quantidade maior de exemplos de código, comparando o desenvolvimento das mesmas tarefas em ambas as plataformas alvos de seu trabalho.

\subsection{Resumo dos resultados alcançados}

Ambas as tecnologias possuem seus pontos fortes e fracos. De modo geral, o uso de \lang{Java} com o \lib{Spring Framework} proporciona melhor controle do projeto ao desenvolvedor e a liberdade de utilizar uma gama maior de bibliotecas para sua configuração. Mas essa liberdade tem um custo, o desenvolvedor de modo geral, precisa escrever mais código de configuração e pesquisar como os componentes escolhidos interagem para que o projeto seja bem sucedido.

A tecnologia \sigla{ASP.NET MVC} é mais fechada (apesar de ter seu código ser aberto), existem muitas convenções que o desenvolvedor deve obedecer e não existe tanta liberdade para configuração, tudo é mais padronizado. A vantagem disso é que o desenvolvedor se preocupa menos em como vai configurar sua aplicação e ele pode usar esse tempo para escrever código que realmente agrega valor ao produto.

De modo geral, se o desenvolvedor dispuser de tempo e precisar de um controle maior sobre o projeto, o uso da tecnologia \lang{Java} é aconselhável. Por outro lado, se o projeto tiver um prazo reduzido ou o desenvolvedor preferir seguir convenções e não quiser se preocupar em como vai ter que configurar o projeto, a tecnologia \lib{.NET} pode ser uma melhor opção.
 
\subsection{Publico alvo}

Esse trabalho pode beneficiar gerentes de projetos e lideres técnicos à escolher qual das duas tecnologias utilizar para iniciar um novo projeto. Estudantes interessados em começar a desenvolver para a \est{web} também podem se beneficiar desse trabalho e aprender o básico sobre as duas tecnologias.

\subsection{Metodologia de pesquisa}

A maior fonte da informação para esse trabalho foram livros, em sua maioria as edições mais recentes. Além dos livros, foram utilizados como fonte de pesquisa as documentações online de ambas as tecnologias. Também foram utilizados como fonte de pesquisa, exemplos encontrados em sites de desenvolvedores na internet, sendo o mais utilizado o \est{stack overflow} americano.

\newpage
\section{Configuração de ambiente de desenvolvimento}

Neste capitulo é demonstrado o preparo do ambiente de desenvolvimento em um computador rodando o sistema operacional \est{Windows 8.1} de 64 \est{bits}. Primeiramente, instala-se um sistema gerenciador de banco de dados para trabalhar tanto com a plataforma \spring quanto com a plataforma \anmvc.  O banco de dados usado é o \est{MySQL Community Server} versão 5.6.22 (a versão mais atual até o momento de criação desta monografia). A \est{Integrated Development Environment} (\sigla{IDE}) utilizada  para escrever código em \lang{Java}, é o \est{Eclipse Luna}. O \est{Gradle} é usado como \est{build tool} e o \est{Apache Tomcat} como \est{container} \est{Java Enterprise Edition} (\sigla{JEE}). Para desenvolver em \lang{C\#}, é usado o \est{Visual Studio 2013 Community}. Considerando que o leitor já possui entendimentos sobre informática necessários para instalar programas no \est{Windows}, as instruções de instalação serão sucintas. 

\subsection{Instalação do MySQL}

O download do instalador do \est{MySQL Community} foi feito no seguinte endereço \url{https://dev.mysql.com/downloads/windows/installer/5.6.html}. O instalador está disponível duas versões, \est{web installer} e \est{off-line installer}. O \est{web installer} é um arquivo pequeno que quando executado irá baixar os arquivos do \sigla{MySQL} para a máquina, o \est{off-line installer} é maior e vem com todos os arquivos necessários para a  instalação do \sigla{MySQL}. Qualquer que seja o método de instalação escolhido, eles terão as mesmas opções.

Executando o instalador, é escolhida a opção \est{Custom} e na árvore de opções que aparecerá na tela a seguir, são escolhidos o \est{MySQL Server}, o \est{MySQL Workbench}, o \est{Connector/J} (para \lang{Java}) e o \est{Connector/NET} (para \sigla{.NET}), como mostrado na Figura~\ref{fig:sql1}. Pode acontecer do instalador pedir para instalar o \est{Microsoft Visual C++ 2013} como dependência do \est{MySQL Workbench}, se isso acontecer, o próprio instalador proverá um botão para instalar essa dependência.

\figura{mysqlinstaller1.jpg}{Opções de instalação do \mysql}{fig:sql1}

Concluída a instalação, é hora de configurar o serviço do \sigla{MySQL}. Deixa-se selecionado o tipo de configuração como \est{Development Machine} e as configurações de rede padrão (protocolo \sigla{TCP/IP}, porta 3306). Quando for necessária a senha do usuário \est{Root}, é usada “1234”, é uma senha fraca que não se recomenda usar em ambiente de produção, mas serve para propósito de exemplo. Finaliza-se a configuração deixando marcados os restantes das opções de configuração como padrão do instalador.

Com o objetivo de testar o sucesso da instalação, o desenvolvedor pode executar o \est{MySQL Workbench}, como ilustrado na Figura~\ref{fig:sql2}, e tentar se conectar à instancia do MySQL.

\figura{mysqlinstaller2.jpg}{O \mysql \est{Workbench}}{fig:sql2}

Para mais informações sobre o \sigla{MySQL}, visite a página oficial do projeto, \url{https://www.mysql.com/}.

\subsection{Preparando o ambiente \lang{Java}}

Para desenvolver em \lang{Java}, é utilizado o \est{Eclipse Luna} e o \est{Java Development Kit 8} (\sigla{JDK 8}). é usado o \est{Gradle} como \est{build tool} através de um \est{plugin} do \est{Eclipse} e o servidor \est{web} utilizado é o \est{Apache Tomcat}.

\subsubsection{Instalando JDK 8}

O instalador do \sigla{JDK 8} pode ser adquirido no endereço \url{http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html}. Existem diversas versões para diversos sistemas operacionais, é usado nesse trabalho a versão para \est{Windows} de 64 \est{bits}. 

Para fazer a instalação do \sigla{JDK}, é executado o arquivo de instalação seguindo as suas instruções. A única configuração possível durante a instalação é a mudança da sua pasta de destino, mas é mantido o diretório padrão como mostrado na Figura~\ref{fig:jdk1}.

\figura{jdk81.jpg}{O instalador do \sigla{JDK 8}}{fig:jdk1}

Terminada a instalação, é necessário configurar a variável \est{PATH} para que o sistema encontre os arquivos do \lang{Java}. Essas opções de configuração estão no painel de controle do \est{Windows}, no caminho Sistema/Configurações avançadas do sistema/Variáveis de ambiente. Na janela de variáveis do sistema, é editada a variável \est{PATH}. Se adiciona o caminho onde o \sigla{JDK} foi instalado acrescido da pasta bin (C:\textbackslash Program Files\textbackslash Java\textbackslash jdk\textmd{1.8.0\_25}\textbackslash bin) como mostrado na Figura~\ref{fig:path}.

\figura{path1.png}{Configurando a variável \est{PATH}}{fig:path}

Para testar se tudo foi instalado corretamente, abre-se uma janela do \est{prompt} de comando e digita-se o comando \est{“java –version”} (sem aspas). Se não existirem problemas, é exibida na tela o número da versão do \sigla{JDK} instalado. Caso isso não aconteça, é aconselhável desinstalar o \sigla{JDK} e repetir o processo de instalação. 

\subsubsection{Instalando o \est{Eclipse Luna}} 

O \est{Eclipse Luna} para Desenvolvedores \est{Java EE} é encontrado no endereço \url{https://www.eclipse.org/downloads/}. Terminando o \est{download}, a pasta \est{“eclipse”} pode ser descompactada para qualquer diretório do computador. Coloca-se um atalho na sua área de trabalho para o executável do \est{Eclipse} (eclipse.exe) para facilitar o acesso.

Na primeira vez que o \est{Eclipse} é executado é exibida uma janela para configurar o \est{Workspace} padrão (uma pasta onde serão guardados projetos e configurações), como está ilustrado na Figura~\ref{fig:eclipse1}.

\figura{eclipse1.png}{\est{Eclipse} recém instalado}{fig:eclipse1}

\subsubsection{Instalando o \est{plugin} do \est{Gradle}} 

O \est{Gradle} é a \est{build tool} que é utilizada nos exemplos do projeto \spring. Ele faz o mesmo trabalho que o \est{ANT} associado ao \est{Ivy} ou o \est{Maven} fazem, mas ele é considerado por alguns autores como o mais moderno em se tratando de \est{build tools}, pois seus \est{scripts} são escritos em \lang{Groovy} em vez de \sigla{XML} e ele permite configurações que o \est{Maven} não permite. O \est{Gradle} está presente em todo ciclo de vida do software (ele gera artefatos, executa teste unitários, resolve dependências e executa integração continua), mas nesse trabalho é usada apenas uma pequena parte do que ele pode oferecer. Para mais informações sobre o \est{Gradle} acesse \url{https://www.gradle.org}. 

No \est{Eclipse Marketplace} (repositório de \est{plugins} do \est{Eclipse}), faz-se uma pesquisa por \est{"Gradle"} na barra de buscas, entre os resultados está o \est{Gradle IDE Pack}. Esse \est{plugin} é usado nos exemplos desse trabalho. O \est{Eclipse} pede confirmação para instalação de todos os pacotes necessários, todos são selecionados e instalados. Aceita-se os termos de uso do \est{Gradle} e ao aparecer uma janela de alerta confirmando a instalação, clica-se em OK. Quando a instalação terminar, o \est{Eclipse} é reiniciado.

Para verificar se o \est{plugin} foi instalado com sucesso, a pasta \est{Gradle} deve aparecer na arvore de tipos de projetos, no menu de novos projetos, como pode ser observado na Figura~\ref{fig:gradle1}.

\figura{plugin1.png}{Instalando o \est{plugin} do \est{Gradle}}{fig:gradle1}

\subsubsection{Instalando o \est{Apache Tomcat 8} como servidor de desenvolvimento do \est{Eclipse}} 

O \est{Java Enterprise Edition} é um conjunto de especificações que precisam ser implementadas por um \est{container} (um servidor de aplicação ou servidor \est{web}) que irá executar efetivamente a aplicação. Existem diversos \est{containers} disponíveis no mercado, sendo o \est{GlassFish} o próprio \est{container} da \est{Oracle}. Nesse trabalho é usado o \est{Apache Tomcat}, pois o \est{Eclipse} tem integração nativa com ele. O \est{Tomcat} pode ser gerenciado pela aba de servidores do \est{Eclipse}.

O instalador do \est{Tomcat 8} pode ser encontrado no endereço \url{https://tomcat.apache.org/download-80.cgi}. Para os exemplos, usa-se a distribuição para \est{Windows} de 64 bits no formato \est{zip}. A pasta \est{apache-tomcat-8.0.15} pode ser descompactada para qualquer diretório no disco rígido (como exemplo é usada a raiz do disco C:).  

Na aba \est{Servers} do Eclipse existe um \est{link} auto descritivo para adicionar um novo servidor. Clicando no \est{link} e expandindo pasta \est{Apache}, é escolhido o \est{Tomcat 8} na árvore de opções, o que pode ser observado na Figura~\ref{fig:tomcat1}. Na janela seguinte, em \est{Tomcat installation directory}, o botão \est{browse...} é usado para escolher o caminho de instalação do \est{Tomcat} (C:\textbackslash apache-tomcat-\textmd{8.0.15}). Clicando no botão \est{Finish}, o \est{Tomcat} está pronto para uso com o \est{Eclipse}. 

\figura{tomcat1.png}{Janela pra adicionar servidores no \est{Eclipse}}{fig:tomcat1}

\subsection{Instalando o \est{Visual Studio Community 2013}} 

O instalador do \est{Visual Studio Community 2013} pode ser encontrado no endereço \url{http://www.visualstudio.com/en-us/news/vs2013-community-vs.aspx}. Na Figura~\ref{fig:vs1} temos uma ilustração do instalador em questão. Esse é um instalador \est{online}, ele baixa os arquivos do \est{Visual Studio} e opcionais selecionados à medida que a instalação for progredindo. Uma imagem do DVD de instalação \est{offline} também está disponível na sessão de \est{downloads} do site \url{http://www.visualstudio.com}.

\figura{vs1.png}{Instalador do Visual Studio Community 2013}{fig:vs1}

Clicando no botão \est{Next}, a próxima tela que o instalador exibe uma lista de componentes opcionais como o \est{kit} de desenvolvimento do \est{Windows Phone 8} e do \est{Silverlight}. Desses componentes opcionais, é aconselhável instalar pelo menos o \est{Microsoft Web Developer Tools} para facilitar o desenvolvimento de aplicações \est{web}.

Após a instalação, o desenvolvedor pode utilizar sua conta da \est{Microsoft} como perfil no \est{Visual Studio} e publicar suas aplicações no \est{Microsoft Azure}, porém isso é opcional. Quando se executa o \est{Visual Studio} pela primeira vez, ilustrado na Figura~\ref{fig:vs2}, o desenvolvedor pode escolher as opções de desenvolvimento e um esquema de cores que irá usar. Como exemplo, é escolhida a opção de desenvolvimento \est{Web Development}.

\figura{vs2.png}{Tela inicial do \est{Visual Studio Community 2013}}{fig:vs2}

O \est{Visual Studio} possui sua própria ferramenta de geração de \est{builds} (\est{MsBuild}), gerenciador de pacotes para obter bibliotecas de terceiros (\est{Nuget}) e um servidor de desenvolvimento minimalista baseado no \est{Internet Information Services} (servidor \est{web} do \est{Windows Server}) para executar e depurar aplicações \est{web}.  

\subsection{Conclusão}

A preparação de um ambiente de desenvolvimento \spring requer mais passos, dentre eles instalar o kit de desenvolvimento do \est{Java}, uma \sigla{IDE} (\est{Eclipse}), um \est{container Java Enterprise Edition} (\est{Tomcat}) e uma \est{build tool} (\est{Gradle}), enquanto  todo o \est{software} necessário para se desenvolver com \sigla{.NET} é adquirido em um único instalador.

A vantagem do ambiente \lang{Java} é que ele fornece ao desenvolvedor mais opções de como configurar seu ambiente, além disso o tamanho em \est{megabytes} do \est{software} necessário é consideravelmente menor do que o ambiente \sigla{.NET}. O desenvolvedor tem a liberdade de escolher outras \est{build tools} disponíveis no mercado (Ex: \est{Ant}, \est{Maven}), outras \sigla{IDEs} (Ex: \est{Netbeans}) e outros servidores \est{Java EE} (Ex: \est{Jetty}, \est{Glassfish}). O lado negativo dessa liberdade é que, com  essa variedade de opções, o desenvolvedor tem que pesquisar mais sobre cada solução até decidir como vai montar seu ambiente de desenvolvimento. Então depois de escolher quais produtos irá utilizar, pode ser que precise de mais algum tempo estudando como eles interagem.

A vantagem do ambiente \sigla{.NET} está na facilidade de obter todo o \est{software} necessário para o desenvolvimento em um único pacote, o \est{.NET Framework}, \est{Visual Studio Community 2013} e demais ferramentas. A desvantagem é que esse pacote pode conter componentes que o desenvolvedor não precisa ou deseja, baixando arquivos desnecessários e tomando espaço em disco.

No próximo capitulo é demonstrado como criar um projeto de uma aplicação \est{web} nas duas plataformas.

\newpage
\section{Criando projetos web no padrão \sigla{MVC}}

Nesse capitulo é mostrado como criar um novo projeto para uma aplicação \est{web} que utiliza o padrão \sigla{MVC} nas plataformas \spring e \anmvc. Para \lang{Java} serão usadas as bibliotecas \est{Spring Framework}, que cuidará da arquitetura \sigla{MVC} e injeção de dependências, e o \est{Hibernate}, que cuidará da persistência e acesso a dados. Na plataforma \sigla{.NET} é utilizado o \sigla{ASP.NET MVC 5}, que cuida de toda estrutura de uma aplicação web \sigla{MVC}, o \est{Entity Framework 6} para acesso a dados e o \est{Ninject} para injeção de dependências.

\subsection{Criando um projeto do \est{Gradle} no \est{Eclipse}}

O modelo de projeto usado nos exemplos desse trabalho é o \est{Gradle Project}. Esse modelo de projeto está localizado na pasta \est{Gradle} na arvore de novos projetos do \est{Eclipse}. Na Figura~\ref{fig:gradleproject} pode-se observar a localização do modelo e a criação do novo projeto.

\figura{gradleproject1.png}{Criando um projeto do \est{Gradle}}{fig:gradleproject}

É criado um projeto com a estrutura mostrada na Figura~\ref{fig:gradletree}.

\figura{gradleproject1.png}{Estrutura inicial de um projeto do \est{Gradle}}{fig:gradletree}

As pastas \arquivo{"src/main/java"} e \arquivo{"src/main/resources"} devem armazenar, respectivamente, código fonte \lang{Java} e recursos utilizados na aplicação.  As pastas \arquivo{"src/test/java"} e \arquivo{"src/test/resources"} são utilizadas para testes unitários. As pastas de testes não serão utilizadas nos exemplos e são removidas. A pasta \est{build} é para onde irão todos os artefatos gerados pelo projeto.

O arquivo \arquivo{build.gradle}, exibido no quadro~\ref{lst:1}, é o arquivo de definição de projeto do \est{Gradle}. Nele podem ser criados \est{scripts} para controlar a construção de artefatos, adquirir bibliotecas de terceiros, configurar testes unitários e realizar várias outras tarefas. Os \est{scripts} do \est{Gradle} são escritos em \lang{Groovy}, outra linguagem compatível com a máquina virtual \lang{Java}. 

\groovycode{code/buildgradle.txt}{O arquivo \est{build.gradle}}{lst:1}

A estrutura do projeto e o arquivo \arquivo{build.gradle} gerados devem ser modificados para servir à uma aplicação \est{web}. é adicionada uma nova pasta, chamada de \est{WebContent}, para armazenar conteúdo especifico para \est{web} (páginas \est{jsp/html}, arquivos \lang{javascript} e \lang{css}). Dentro dela deve ser criada uma pasta chamada \est{WEB-INF} para armazenar páginas \est{jsp}. Por padrão, usuários de sistemas \est{web} \est{Java Enterprise Edition} não possuem acesso direto à pasta \est{WEB-INF}, então é um lugar seguro para armazenar páginas. Na Figura~\ref{fig:12} pode ser observada a estrutura do projeto com a pasta \est{WEB-INF}.

\figura{prrojetocomweninf.png}{Estrutura do projeto com a pasta \est{WebContent}}{fig:12}

Em seguida, é necessário modificar o arquivo \arquivo{build.gradle}. O \est{Gradle} dispõe de vários \est{plugins} que facilitam seu uso em diversas situações e servem a propósitos específicos. Para gerar arquivos \arquivo{.war} (artefatos de aplicações \est{web}) e informar ao \est{Gradle} que a pasta \est{WebContent} armazenará o conteúdo especifico para \est{web}, é utilizado o \est{plugin} chamado \est{war}. Para fazer com que o \est{Eclipse} veja o projeto como um projeto para \est{web} que possa ser enviado para o \est{Tomcat}, é utilizado o \est{plugin} \est{eclipse-wtp}. O início do arquivo \arquivo{build.gradle} deverá ficar como no exemplo do quadro~\ref{lst:2}.

\groovycode{code/newgradle.txt}{Arquivo \arquivo{build.gradle} com novos \est{plugins}}{lst:2}

Com tudo devidamente configurado, é necessário atualizar o tipo de projeto para que o \est{Eclipse} o veja como um projeto de uma aplicação \est{web}. Pressionando Ctrl + Alt + Shift + R o \est{Eclipse} abrirá uma caixa de texto onde poderão ser executadas tarefas do \est{Gradle}. Uma dessas tarefas é o comando \est{"eclipse"} que gera arquivos adicionais para que o projeto possa ser detectado como uma aplicação \est{web}. O comando é executado como na Figura~\ref{fig:13} e o \est{Eclipse} agora poderá publicar a aplicação no \est{Tomcat}.

\figura{gradlecommand.png}{\est{Gradle Task Quick Launcher}}{fig:13}

Após executar esse comando, a estrutura do projeto mudará um pouco. As pastas destinadas a conter código \lang{Java} e bibliotecas usadas no projeto serão movidas para uma pasta chamada \est{Java Resources}.

\subsubsection{Adicionando o projeto ao \est{Tomcat}}

Para adicionar uma aplicação \est{web} ao servidor \est{Tomcat} configurado no \est{Eclipse}, na aba \est{"servers"} dá-se um duplo clique no servidor para abrir suas configurações, e na aba \est{"modules"} clica-se no botão \est{"Add Web Module"}. Escolhido o projeto \est{web} que se deseja adicionar, o caminho da aplicação pode ser configurado. A Figura~\ref{fig:14} ilustra esse procedimento. Com a configuração padrão do \est{Tomcat}, a aplicação estará disponível no endereço com o seguinte formato: \url{http://<endereço-ip>:8080/<caminho-da-aplicação>}. Esse endereço é referenciado no restante do trabalho como raiz da aplicação.

Iniciando o \est{Tomcat}, clicando nos botões \est{"Start the server"} ou \est{"Start the server in debug mode"}, e acessando o endereço da aplicação, é mostrado uma página de erro 404. Isso acontece porque ainda não existem as configurações do \est{servlet} padrão, do \est{Spring MVC} e ainda não foi criado nenhum \est{controller} e nenhuma \est{view}. Nesse capítulo ainda é demonstrado como configurar o \est{servlet} padrão e o \est{Spring MVC}, no capitulo 3 é demonstrado como se criam \est{controllers} e \est{views}.

\figura{tomcatproject.png}{Adicionando um projeto web ao \est{Tomcat}}{fig:14}

\subsubsection{Adicionando dependências ao projeto}

Abaixo estão listadas as bibliotecas que são usadas no projeto \spring. O \est{Gradle} pode adquirir essas bibliotecas e suas dependências do repositório central do \est{Maven}.

\begin{itemize}
  \item \lib{Java Servlet API 3.1.0} - Biblioteca base para programar em \lang{Java} para \est{web} usando \est{servlets}.
  \item \lib{Spring Web MVC 4.1.4 RELEASE} - Biblioteca para criar um projeto \sigla{MVC} com \est{Spring}.
  \item \lib{Spring Transaction 4.1.4 RELEASE} - Gerenciador de transações com o banco de dados.
  \item \lib{Spring Object/Relational Mapping 4.1.4 RELEASE} - Gerenciador de entidades e mapeamento objeto/relacional.
  \item \lib{Jackson Databind 2.5.1} - Serializa e de deserializa objetos \lang{Java} no formato \sigla{JSON}.
  \item \lib{MySQL Java Connector 5.1.34} - Comunicação com o banco de dados \est{MySQL}.
  \item \lib{Hibernate JPA Support 4.3.8 Final} - Adaptador do \est{Hibernate} para padrões \est{Java Persistence API}.
  \item \lib{Hibernate Validator Engine 5.1.3 Final} - Biblioteca para validar dados de entidades.
  \item \lib{Hibernate c3p0 Integration 4.3.8} - Gerenciador de conexões com o banco de dados.
\end{itemize}

Os detalhes sobre as funcionalidades das bibliotecas de comunicação com o banco de dados e mapeamento objeto/relacional são abordados no capítulo 6. 

Para fazer com que o \est{Gradle} adquira as bibliotecas necessárias e suas dependências, a seção \est{"dependencies"} do arquivo \arquivo{build.gradle} é alterada como mostra o quadro~\ref{lst:3}.

\groovycode{code/gradledependencies.txt}{Adicionando dependências ao projeto}{lst:3}

Com o arquivo \arquivo{build.gradle} alterado e salvo, o comando para baixar as dependências para o projeto está localizado no menu de contexto do projeto (clicando com o botão direito do \est{mouse} sobre ele) no caminho \est{Gradle/Refresh Dependencies}, que pode ser observado na Figura~\ref{fig:15}. O \est{Gradle} irá adquirir todas as bibliotecas especificadas no arquivo \arquivo{build.gradle} e suas dependências automaticamente. O \est{Spring MVC}, por exemplo, depende do \est{Spring Core} para funcionar e o \est{Hibernate JPA Support} precisa do \est{Hibernate Core}. Todas as dependências do projeto ficam visíveis na seção \est{Libraries/Gradle Dependencies}.

\figura{refreshdependencies.png}{Atualizando dependências de um projeto \est{Gradle}}{fig:15}

\subsubsection{Configurando a aplicação \est{web}}

Existem duas maneiras de se configurar uma aplicação \lang{Java}, usando arquivos \lang{XML} ou escrevendo a configuração em \lang{Java}. Nos exemplos dessa seção, é usada a segunda opção.

Os arquivos de configuração são armazenados no pacote \pacote{br.uece.webCrud.config}. Dentro desse pacote são criadas duas classes, \classe{AppInitializer} e \classe{SpringMvcConfig}, como mostra a Figura~\ref{fig:16}. 

\figura{configpackage.png}{Estrutura do projeto \spring com pacote para arquivos de configuração}{fig:16}

A primeira configuração que deve ser feita é usar a classe \classe{DispatcherServlet} como o \est{servlet} padrão e configurar o contexto da aplicação (configurações especificas do \est{Spring Framework}). \est{Servlets} são classes \lang{Java} que processam requisições para aplicação, elas podem servir páginas para o usuário, retornar objetos \sigla{JSON}, redirecionar requisições para outros \est{servlets}, ETC. Para mais informações sobre \est{servlets} recomenda-se o livro \est{Murach’s Java Servlets and JSP}.

A classe \classe{AppInitializer} herda da interface \classe{WebApplicationInitializer}. Para inicializar a aplicação, o \est{Spring Framework} irá procura classes que herdam dessa \est{interface} dentro dos pacotes. O conteúdo da classe deve estar como no quadro~\ref{lst:4}.

A interface \classe{WebApplicationInitializer} possui a assinatura de apenas um método, \metodo{onStartup}. Na implementação desse método é escrito código para configurar tanto o contexto da aplicação quando o \est{servlet} primário.

Primeiro é criado um objeto do tipo \classe{AnnotationConfigWebApplicationContext} e é usado o seu método \metodo{register} para adicionar a classe \classe{SpringMvcConfig} como uma classe de configuração do \est{Spring}. A classe \classe{AnnotationConfigWebApplicationContext} habilita o uso de anotações \lang{Java} para configurar demais classes, o conteúdo da classe \classe{SpringMvcConfig} é exposto mais adiante.

É criado então um \est{servlet} do tipo \classe{DispatcherServlet} que recebe o contexto como parâmetro e é usada a classe \classe{ServletRegistration} para registrar o \est{servlet} à aplicação. O método \metodo{addMapping} recebe como parâmetro o caractere "/", isso quer dizer que esse \est{servlet} é usado para todas a páginas \est{web} e demais caminhos dentro da aplicação. O método \metodo{setLoadOnStartup} recebe como parâmetro o valor 1, para configurar o \est{servlet} como o primeiro que o servidor deve usar.

\javacode{code/AppInitializer.txt}{Classe \classe{AppInitializer}}{lst:4}

Vários objetos que fazem parte da estrutura da aplicação (também conhecidos como \est{Spring Beans}) são configurados na classe \classe{SpringMvcConfig}, como mostra o quadro~\ref{lst:mvcconfig}. A anotação \annotation{@Bean} do \est{Spring Framework} decora métodos na classe \classe{SpringMvcConfig} que retornam objetos que são usados no núcleo da aplicação e definem seu contexto.

A classe \classe{SpringMvcConfig} começa decorada com as seguintes anotações:

\begin{itemize}
  \item \annotation{@Configuration} - Define a classe como uma classe de configuração do \est{Spring Framework}.
  \item \annotation{@EnableWebMvc} - Habilita o \est{Spring MVC}.
  \item \annotation{@EnableTransactionManagement} - Habilita o controle automático de transações com o banco de dados pelo \est{Spring Framework}.
  \item \annotation{@ComponentScan} - Configura os nomes de pacotes onde o \est{Spring IoC Container} deve procurar classes decoradas a anotação \annotation{@Component} e suas especializações, como \annotation{@Repository}, \annotation{@Service} e \annotation{@Controller} (Mais detalhes sobre essas anotações em capítulos posteriores).  
\end{itemize}

\javacode{code/mvcconfig.txt}{Classe \classe{SpringMvcConfig}}{lst:mvcconfig}

A classe começa definindo várias propriedades que são usadas para a criação da conexão com o banco de dados, como o \est{driver} a ser utilizado, localização, nome do banco, usuário e senha. Outras propriedades armazenam configurações do \sigla{JPA} (implementadas pelo \est{Hibernate}), como qual dialeto do \sigla{SQL} usar para gerar consultas no banco (dialeto do \est{MySql 5}), qual a ação executar na configuração \est{hibernate.hbm2ddl.auto} (\est{"create"} para criar o banco de dados e gerar tabelas a partir de classes decoradas com a anotação \annotation{@Entity}) e qual o esquema padrão a ser usado nas consultas (normalmente o mesmo nome do banco de dados no \est{MySql})

A classe \classe{SpringMvcConfig} herda da classe \classe{WebMvcConfigurerAdapter} para ter acesso a alguns métodos que facilitam a configuração da aplicação. Esses métodos decorados com \annotation{@Override} configuram o uso do \classe{ServletHandler} padrão do \est{Spring} e como a aplicação deve servir diferentes tipos de conteúdo ao usuário.

Os dois primeiros métodos decorados com \annotation{@Bean} retornam objetos com informações de onde e como encontrar as \est{views} da aplicação. O \classe{InternalResourceViewResolver} armazena configurações sobre em que diretório estão as \est{views} (\est{WEB-INF}) e suas extensões (\est{.jsp}). Assim é dito ao \est{Spring Framework} para procurar páginas \est{.jsp} dentro do caminho \arquivo{/WebContent/WEB-INF}.

O Segundo método configura o \classe{ContentNegotiatorViewResolver}, uma classe de uso interno do \est{Spring} que resolve \est{views} baseadas no cabeçalho das requisições \sigla{HTTP}. Note que ele recebe uma coleção de \classe{ViewResolvers} como parâmetro e é adicionado o \classe{InternalResourceViewResolver} do método anterior nessa lista.

Os três últimos métodos decorados com a anotação \annotation{@Bean} retornam objetos relacionados ao uso do banco de dados e manipulação de entidades. O primeiro deles retorna um objeto do tipo \classe{ComboPooledDatasource} que recebe vários parâmetros para se conectar ao banco de dados e servir como fonte de dados para a aplicação. 

O segundo método cria um objeto do tipo \classe{LocalContainerEntityManagerFactoryBean} que gerenciará a criação de uma implementação da interface \classe{EntityManager}. Implementações de \classe{EntityManager} são usadas nos repositórios para persistir objetos e consultar o banco de dados. Entre os parâmetros que o \classe{LocalContainerEntityManagerFactoryBean} recebe estão um adaptador para o uso do \est{Hibernate}, o nome do pacote onde são criadas entidades e o \classe{ComboPooledDatasource} configurado anteriormente para ser usado como fonte de dados. Ele também recebe um objeto do tipo \classe{Properties} contendo várias configurações do \est{Java Persistence API} (\sigla{JPA}). Para informações mais detalhadas sobre o \sigla{JPA}, recomenda-se o livro \est{Pro JPA 2.0}, 2ª edição, da editora \est{Appress}.

O último método retorna um objeto \classe{JpaTansactionManager}. Esse objeto é o responsável por gerenciar as transações com o banco de dados. Ele recebe a instancia do objeto \classe{LocalContainerEntityManagerFactoryBean} configurado anteriormente como parâmetro.

\subsection{Criando um projeto \anmvc no \est{Visual Studio Community 2013}}

O link \est{"new project..."}, na tela inicial do Visual \est{Studio Community 2013}, mostra um menu com diversos modelos para criação de projetos. Para o projeto desse trabalho, é usando o \est{"ASP.NET Web Application"} o menu \est{"Visual C\#"}.

Um projeto no \est{Visual Studio} faz parte de uma solução. Uma solução além de ser uma coleção de projetos, contém informações de dependências e configurações. A Figura~\ref{fig:17} ilustra a criação de um novo projeto. Os arquivos de solução junto com os de projeto são os equivalentes aos arquivos de projeto do \est{Eclipse} e o arquivo \arquivo{build.gradle}. vsnewproject.png

\figura{vsnewproject.png}{Criando um novo projeto no \est{Visual Studio Community 2013}}{fig:17}

O nome da solução de exemplo é \est{"NetWebCrud"}. O \est{Visual Studio} automaticamente dá o mesmo nome da solução para o primeiro projeto criado. O local de armazenamento dos arquivos também pode ser configurado nessa tela. Clicando no botão "OK", aparecerá o menu mostrado na Figura~\ref{fig:18}.

\figura{vsnewproject2.png}{Opções de um novo projeto \est{web} no \est{Visual Studio}}{fig:18}

Existem várias opções de projetos para \est{web}. Para um projeto \sigla{MVC} contendo apenas o mínimo necessário para seu funcionamento, é escolhido o modelo \est{"Empty"} e é marcada a opção \sigla{MVC}. O serviço \est{Microsoft Azure} não é utilizado, então a opção \est{"Host in the Cloud"} é desmarcada. Clicando em "OK", o \est{Visual Studio} irá gerar um projeto com a estrutura mostrada pela Figura~\ref{fig:19}.

\figura{19.png}{Estrutura de um projeto \anmvc}{fig:19}

O \anmvc funciona seguindo o princípio de convenção à configuração. O desenvolvedor deve seguir várias convenções para o desenvolvimento de sua aplicação, em compensação, a quantidade de configuração necessária é mínima.

Todas as páginas, e subpastas que contém páginas, devem ficar inseridas na pasta \est{Views}, todos os \est{controllers} devem fica na pasta \est{Controllers}. No \sigla{ASP.NET MVC} existe o conceito de \est{Areas}, onde o desenvolvedor pode organizar melhor seu código, mas esse conceito não é abordado nesse trabalho. A pasta \est{Models} pode conter entidades de negócio, repositórios e quaisquer outras classes da camada \est{Model} do padrão \sigla{MVC}, mas o desenvolvedor também pode criar tais classes em outros projetos dentro da solução.

A classe \classe{AssembyInfo} contém informações como nome da aplicação, empresa desenvolvedora e número de versão. Esse arquivo pode ser editado pelo desenvolvedor para atualizar os metadados da aplicação. A pasta \est{References}, contém as bibliotecas que são usadas no projeto. A pasta \est{App\_Data} pode conter um arquivo de banco de dados minimalista para armazenar dados, mas como é usado o banco de dados \est{MySql}, essa pasta é apagada manualmente.

A pasta \est{App\_Start} existe para que o desenvolvedor possa armazenar arquivos de inicialização da aplicação. Um modelo de um novo projeto \anmvc vêm com a classe \classe{RouteConfig} onde a tabela de rotas que mapeia \sigla{URLs} para \est{controllers} é configurada. Esse conteúdo desse arquivo é explicado no próximo capítulo durante a criação de \est{controllers}.

O arquivo \arquivo{Global.asax} contém o método \metodo{Application\_Start}. Esse método é chamado uma vez quando a aplicação é iniciada e nele podem ser incluídas linhas de código que serão executadas quando a aplicação iniciar. No modelo de projeto escolhido, ele já vem com uma chamada ao método \metodo{RegisterRoutes} da classe \classe{RouteConfig} e \metodo{RegisterAllAreas} da classe \classe{AreaRegstration}.

O Arquivo \arquivo{Web.config} na pasta raiz do projeto é um arquivo \lang{XML} que contém diversas configurações para o projeto. O arquivo \arquivo{web.config} na pasta \est{Views} contém configuração apenas para a criação de \est{views}.

\subsubsection{Adicionando dependências usando o \est{NuGet}}

Do mesmo modo que o \est{Gradle} pode adicionar bibliotecas externas ao projeto \lang{Java}, o \est{NuGet} é uma ferramenta que adiciona e gerencia pacotes nos projetos do Visual Studio. Nesse projeto de exemplo são usadas as seguintes bibliotecas:

\begin{itemize}
  \item \lib{MySql.Data.Entity 6.9.5} - Biblioteca necessária para o \est{MySql} funcionar com o \est{Entity Framework 6}. Adicionando essa biblioteca, o \est{NuGet} também adiciona o \est{driver do MySql} e o \est{Entity Framework 6} ao projeto.
  \item \lib{Ninject MVC5 3.2.2} - Injeção de dependências para projetos \anmvc. 
\end{itemize}

O console do \est{NuGet} pode ser acessado no menu \est{TOOLS/NuGet Package Manager/Package Manager Console}, como mostra a Figura~\ref{fig:20}.

\figura{20.png}{Acessando o console do \est{NuGet}}{fig:20}

O console do \est{NuGet} é exibido no \est{Visual Studio} como mostra a Figura~\ref{fig:21}. Nele o desenvolvedor pode digitar comandos para procurar e adquirir bibliotecas para seus projetos.

\figura{21.png}{Console do NuGet}{fig:21}

Para instalar as bibliotecas citadas anteriormente, executa-se os seguintes comandos no console do \est{NuGet}:

\begin{itemize}
  \item \est{Install-package mysql.data.entity}
  \item \est{Install-package ninject.mvc5}
\end{itemize}

Quando o \est{NuGet} terminar de baixar todos os arquivos, eles são adicionado ao projeto. A Figura~\ref{fig:22} ilustra a instalação das bibliotecas.

\figura{22.png}{Console do \est{NuGet}}{fig:22}

Ao terminar a instalação, os arquivos \arquivo{packages.config} e \arquivo{Web.config} são atualizados com as referências e configurações das novas bibliotecas.

A instalação do \est{Ninject Mvc 5} adiciona o arquivo \arquivo{NinJectWebCommon.cs} à pasta \est{App\_Start}. Na Figura~\ref{fig:23} pode-se observar o arquivo adicional citado. O conteúdo e funcionalidade desse arquivo é abordado no capitulo 5.

\figura{23.png}{Arquivo adicional do \est{Ninject}}{fig:23}

\subsubsection{Adicionando informações de conexão com o banco de dados}

O acesso ao banco de dados é configurado no arquivo \arquivo{Web.config} na raiz do projeto. Para adicionar informações de conexão com o banco \est{MySql}, é adicionada a \est{tag} \est{connectionStrings} como no exemplo mostrado no quadro~\ref{lst:6}.

\xmlcode{code/6.txt}{Adicionando configurações de conexão ao \arquivo{Web.xml}}{lst:6}

A \est{tag} \est{configuration} é a raiz do arquivo de configuração. A \est{tag} \est{configSections} deve ser a primeira filha da \est{tag} raiz, caso não seja, a aplicação irá reportar um erro de configuração. Note que já existem referências ao \est{Entity Framework}. A \est{tag} \est{connectionStrings} deve ser filha da \est{tag} \est{configuration}.

A \est{tag} \est{add} é usada para adicionar informações de conexão com o banco de dados. É necessário dar um nome para a conexão, configurar a \est{connection string} propriamente dita e o nome da classe responsável pelo acesso ao banco. A \est{connection string} deve conter no mínimo informações sobre para qual servidor apontar, qual o nome do banco de dados e usuário/senha utilizados. 

\subsection{Conclusão}

Criar um novo projeto com o \est{Spring MVC} requer escrita de código, mais passos e conhecimento de como o \est{framework} funciona internamente. A vantagem de um projeto com \est{Spring} é a questão da modularidade de componentes (o desenvolvedor adiciona ao projeto somente aquilo que precisa) e uma liberdade maior de configuração.

Uma maneira de tornar a configuração inicial de projetos \lang{Java} com \est{Spring} mais simples é usar o módulo \est{Spring Boot}. O \est{Spring Boot} configura automaticamente a aplicação a partir dos arquivos \est{.jar} contidos no projeto. Ele detecta as bibliotecas populares e "adivinha" como o projeto deve ser configurado. Internamente ele cria de forma automática a configuração que foi demonstrada na seção 2.1.3.

As vantagens de criação de um novo projeto \est{ASP.NET MVC} no \est{Visual Studio} são os modelos de projetos que já vem prontos logo após a instalação. Não existe a necessidade de realizar tantas configurações iniciais, contudo menos aspectos do projeto são configuráveis. O desenvolvedor deve obedecer as convenções do \est{ASP.NET MVC}.

No próximo capitulo será mostrado como criar \est{controllers} e \est{views} nos dois tipos de projetos.

\newpage
\section{Criando controllers e views}

Um \est{controller} é uma classe que  recebe requisições, processa informações (ou chama outras classes processa-las) e devolve um resultado ao usuário. Resultados comuns são páginas da \est{web} e objetos \sigla{JSON} ou \sigla{XML} para processamento no navegador (usando Javascript). \est{Views}, no contexto de uma aplicação \est{web}, são as próprias páginas que serão exibidas ao usuário.

Nesse capitulo é demonstrado como criar \est{controllers} e \est{views} em ambos os ambientes de desenvolvimento. São expostos exemplos de como criar \est{controllers} com ações que retornam páginas, objetos \sigla{JSON} e exemplos de ações que aceitam parâmetros. São dados também exemplos de como usar as \est{view engines} que geram páginas \sigla{HTML} dinamicamente.

\subsection{Criando um \est{controller} com uma ação que retorna uma página}

Uma das funções mais comuns dos \est{controllers} é retornar páginas para o usuário. Nas próximas seções é criado um \est{controller} simples que irá retornar uma página estática para exibição no navegador.

Numa aplicação \sigla{MVC}, um controller não deve instanciar nem usar métodos de outro \est{controller}. Se o desenvolvedor achar que isso é necessário, é prudente considerar incluir a funcionalidade necessária em uma classe de serviços (ou classe de negócios). \est{Controllers} devem apenas receber requisições, se for o caso chamar outras classes para processar requisições, e no fim devolver o resultado ao usuário. O capitulo 5 abordará a criação de classes de serviço.

Os exemplos desse capítulo, irão manipular uma classe chamada \classe{Person}. Os quadros~\ref{lst:7} e~\ref{lst:8} mostram o código das classes em \lang{Java} e \lang{C\#}.

\javacode{code/7.txt}{Classe \classe{Person} em Java}{lst:7}

A anotação \annotation{@DateTimeFormat} especifica em qual formado o capo de data será escrito. A escolha desse formato será explicada na seção 4.1.2.

\sharpcode{code/8.txt}{Classe \classe{Person} em C\#}{lst:8}

\subsubsection{Java}

Controllers no \est{Spring MVC} são classes decoradas com a anotação \annotation{@Controller}. Essas classes podem estar contidas em qualquer pacote do projeto. No projeto exemplo, elas estarão contidas no \pacote{pacote br.uece.webCrud.controller}. O código contido no quadro~\ref{lst:9} mostra um exemplo de um \est{controller}, com o nome de \classe{PersonController} e com uma ação que retorna uma página.

\javacode{code/9.txt}{\classe{PersonController} no projeto \est{Spring}}{lst:9}

A anotação \annotation{@RequestMapping} configura com qual o caminho, a partir da raiz da aplicação, as ações do \est{controller} são acessadas. A mesma anotação em uma ação configura qual o caminho para acessa-la a partir do caminho do controller. Por exemplo, para acessar a ação \metodo{addPage} o usuário entraria com o endereço <raiz da aplicação>/person/add. É possível não usar o \annotation{@RequestMapping} no \est{controller} e usá-lo apenas na ação, mas fazendo isso o caminho para a ação será em relação à raiz da aplicação. Também é possível configurar para qual método \sigla{HTTP} a ação irá responder. No exemplo acima, a ação é executada apenas para requisições usando o método \est{GET}.

No \est{Spring MVC} uma das maneiras de retornar uma página para o usuário é retornar um objeto \est{String} com o caminho do arquivo da página. Lembrando que na seção 3.1.3 foram configurados um prefixo e um sufixo no objeto \classe{InternalResourceViewResolver}, e na seção 2.1 o \est{Gradle} foi configurado com o nome da pasta onde ficará armazenado o conteúdo especifico da \est{web}. Então o caminho completo para o arquivo que será retornado é <raiz do projeto>/WebContent/WEB-INF/person/add.jsp.

Agora é criada a página que essa primeira ação irá retornar. É criada uma pasta chamada \arquivo{person} dentro de \arquivo{WEB-INF}, e dentro dessa pasta é criado o arquivo \arquivo{add.jsp}, como pode ser visto na Figura~\ref{fig:24}.

\figura{24.png}{Primeira \est{view} adicionada ao projeto \lang{Java}}{fig:24}

O conteúdo do arquivo \arquivo{add.jsp} é editado como no exemplo do quadro~\ref{lst:10}.

\jspcode{code/10.txt}{Arquivo \arquivo{add.jsp}}{lst:10}

A diretiva \est{page} no cabeçalho da página diz ao servidor como tratar o arquivo, no caso como uma página \sigla{HTML}. O resto arquivo é um formulário \sigla{HTML} comum, que recebe dois valores (o nome e a data de nascimento de uma pessoa) e tem um botão que os envia para o servidor. Note que o formulário faz o envio usando o método \est{POST}.

\subsubsection{ASP.NET MVC}

Um \est{controller} é adicionado ao projeto \est{ASP.NET MVC} clicando com o botão direito do mouse na pasta \arquivo{Controllers}, em seguida selecionado as opções \est{"Add"} e \est{"Controller"}. A Figura~\ref{fig:25} ilustra a adição do \est{controller}.

\figura{25.png}{Adicionando um controller no Visual Studio}{fig:25}

São exibidas diversas opções de modelos de \est{controllers}, a opção usada é a \est{"MVC 5 Controller – Empty"} e o \est{controller} foi também nomeado como \classe{PersonController}. Uma das convenções do \est{ASP.NET MVC} é que \est{controllers} sempre tem que terminar com a palavra \est{"Controller"}. Normalmente é recomendado que se nomeie \est{controllers} com o nome da entidade que eles manipulam como prefixo, para facilitar a organização do código.

Também é adicionada uma ação chamada \metodo{Add} que retorna uma página. O código do \est{controller} deve ficar como no quadro~\ref{lst:11}. Note que \classe{PersonController} é subclasse da classe \classe{Controller}.

\sharpcode{code/11.txt}{\classe{PersonController} em \lang{C\#}}{lst:11}

A ação \metodo{Add} retorna um objeto do tipo \classe{ActionResult}, que é uma classe pai de vários tipos de resultados no \est{ASP.NET MVC} como \classe{JSONResult} e \classe{ViewResult}. O método \metodo{View} retorna um \classe{ViewResult}, que é uma página \est{web}. A ação \metodo{Add} também está decorada com anotação \annotation{HttpGet}, logo essa ação irá responder apenas ao método \est{GET}.

No \est{ASP.NET MVC}, o mapeamento de endereço para \est{controllers} e ações é centralizado pela tabela de rotas, não por anotações isoladas em cada \est{controller} e método. Quem configura a tabela de rotas é a classe \classe{RouteConfig}, mostrada no quadro~\ref{lst:12}.

\sharpcode{code/12.txt}{A classe \classe{RouteConfig}}{lst:12}

A configuração da tabela de rotas começa ignorando qualquer requisição a arquivos com extensão \arquivo{.axd}, que são arquivos de recursos do \est{ASP.NET}. Logo em seguida é configurada a rota padrão. O padrão {controller}/{action}/{id} determina que o acesso às ações devem seguir o caminho <raiz da aplicação>/<nome do controller>/<nome da ação>/<parâmetro opcional chamado "id">. Então para acessar a ação \metodo{Add} de \classe{PersonController} o caminho é <raiz da aplicação>/person/add. Note que não é necessário digitar \est{personController} no caminho, apenas o prefixo é necessário. A rota padrão vem configurada com o apontando para uma ação chamada \metodo{Index} de um \est{controller} chamado \classe{HomeController} se apenas o endereço da raiz da aplicação for requisitado. O desenvolvedor pode mudar esses valores. 

Para adicionar uma \est{view}, se clica com o botão direito do \est{mouse} em uma ação e então na opção \est{"Add View..."} como mostrado na Figura~\ref{fig:26}. 

\figura{26.png}{Adicionando uma \est{view} no \est{ASP.NET MVC}}{fig:26}

Outra convenção do \est{ASP.NET MVC} é que views devem ter o nome das ações que as retornam e ficar dentro de uma pasta com o nome do \est{controller}, como na Figura~\ref{fig:27}. É usado o modelo \est{"Empty"} na criação dessa primeira \est{view}. A extensão de arquivos de views em projetos \est{ASP.NET MVC 5} é \arquivo{.cshtml}.

\figura{27.png}{\est{View} adicionada ao projeto \est{ASP.NET MVC}}{fig:27}

A pasta \arquivo{Shared} pode conter \est{views} acessíveis à todos os \est{controllers}. Em alguns modelos de projetos do \est{Visual Studio} ela contém um arquivo chamado \arquivo{\_Layout.cshtml}. Esse arquivo é uma página modelo (ou \est{layout}) usada quando se quer aproveitar uma mesma estrutura para várias \est{views} diferentes. Essa pasta também pode armazenar \est{Partial Views}, que são pedaços de \est{views} e componentes que o desenvolvedor pode usar em diversas páginas. \est{Layouts} e \est{Partial Views} não são abordados nesse trabalho.

O conteúdo do arquivo \arquivo{Add.cshtml} é aditado para que fique igual ao exemplo do quadro~\ref{lst:13}.

\razorcode{code/13.txt}{O arquivo \arquivo{Add.cshtml}}{lst:13}

Tanto no projeto \est{Java/Spring} como no projeto \est{ASP.NET MVC}, quando acessada pelo Google Chrome, a view é exibida como na Figura~\ref{fig:28}. 

\figura{28.png}{Resultado de exibição da \est{view}}{fig:28}

\subsection{Criando ações parametrizadas}

Na seção 4.1, foram criadas ações que respondem ao método \est{HTTP GET} e retornam uma página ao usuário. Nessa seção essa página será utilizada para enviar informações ao servidor utilizando o método \est{HTTP POST}. Na \est{views} de exemplo, o atributo \est{action} não está definido nos formulários, então ele vai enviar informações ao servidor para o mesmo caminho usado para acessá-lo (<raiz da aplicação>/person/add).

Devem ser criadas ações nos \est{controllers} que respondam ao mesmo endereço da página, mas usem método \est{POST}. Essas ações também devem receber as informações que o formulário irá enviar. Isso é feito configurando anotações e adicionando parâmetros às ações em ambos os projetos. Nos exemplos das seções 4.2.1 e 4.2.2 são feitas ações que recebem um objeto do tipo \classe{Person} e o adicionam à uma coleção armazenada em memória.

\subsubsection{Java}

O código presente no quadro~\ref{lst:14} é adicionado à classe \classe{PersonController}:

\javacode{code/14.txt}{Ação de \classe{PersonController} no projeto Java que responde ao método \est{POST}}{lst:14}

A anotação \annotation{@RequestMapping} no método \metodo{addPost} aponta para o mesmo caminho que o método \metodo{addPage} mas ela responde às chamadas usando o método \est{POST}. O método \metodo{addPost} recebe como parâmetro um objeto do tipo \classe{Person}. Os parâmetros de métodos também podem ser decorados com anotações.

A anotação \annotation{@ModelAttribute} permite que o \est{Spring MVC} procure e mapeie valores do cabeçalho \est{HTTP} para o objeto \est{person}. No quadro~\ref{lst:10}, o atributo \est{name} dos elementos \est{input} onde são digitadas as informações de um novo objeto são \est{"name"} e \est{"birthDate"}, os mesmos nomes dos atributos da classe \classe{Person}.

A Figura~\ref{fig:29} mostra as ferramentas de desenvolvedor do \est{Google Chrome} com um exemplo do que acontece quando se envia os dados da página ao servidor.

\figura{29.png}{Enviando dados para o servidor}{fig:29}

No quadro~\ref{lst:7}, o atributo \est{birthDate} da classe \classe{Person} foi decorado com a anotação \annotation{@DateTimeFormat} para que aceite o formato de data “yyyy-MM-dd”, a Figura~\ref{fig:29} mostra que esse é o formato de data que o \est{Google Chrome} envia para o servidor. Se o formato de data não estivesse configurado ou fosse enviado em outro padrão, o servidor enviaria uma reposta de erro 400 (\est{Bad Request}).

Quando chegam ao servidor, os dados são mapeados automaticamente para o parâmetro \est{person} do método \metodo{addPost} como mostrado na Figura~\ref{fig:30}, e a partir daí o desenvolvedor pode trabalhar com os dados.

\figura{30.png}{Objeto \est{person} com parâmetros corretamente populados no projeto \lang{Java}}{fig:30}

O retorno do método \metodo{addPost} redireciona a requisição para outra ação que mostra uma página com uma tabela com todas pessoas adicionadas à lista. As implementações dessa ação e página serão demonstradas em seções posteriores.

\subsubsection{ASP.NET MVC}

O código apresentado no quadro~\ref{lst:15} foi adicionado ao \classe{PersonController}.

\sharpcode{code/15.txt}{\classe{PersonController} do projeto \est{ASP.NET} com nova ação}{lst:15}

O \est{ASP.NET MVC} não guarda o estado de objetos entre requisições, então a lista deve ser guardada como uma variável da aplicação. Armazenada dessa forma, o estado da lista se preserva e está disponível para todos os usuários. Lembrando que em capítulos posteriores, a lista será substituída por serviços que persistem as entidades no bando de dados.

Por convenção do \est{ASP.NET MVC}, a ação do \est{controller} que reponde ao método \est{POST} deve ter o mesmo nome da \est{view} a qual ele responde.  A única configuração necessária é decorar a ação com a anotação \annotation{HttpPost}. O \est{ASP.NET MVC} faz o mapeamento dos dados para o objeto \est{person} de forma semelhante ao \est{Spring MVC}, só que não é necessário especificar o formato do campo \est{birthDate}. A Figura~\ref{fig:31} mostra o resultado do mapeamento.

\figura{31.png}{Objeto \est{person} no \est{ASP.NET MVC} corretamente populado}{fig:31}

Assim como no projeto \est{Java/Spring}, o objeto \est{person} é adicionado em uma lista e a ação redireciona o usuário para uma página que mostra todos os objetos da lista.

\subsection{Retornando um objeto JSON}

Aplicações web modernas utilizam a técnica \sigla{AJAX} para atualizar partes de páginas em vez de enviar uma requisição para que o servidor envie uma página completa novamente. Essa técnica é essencial para dar ao usuário uma melhor experiência de uso da aplicação. Os dados são enviados e recebidos assincronamente utilizando código \lang{Javascript}, esses dados podem estar no formato \sigla{XML} ou \sigla{JSON}. Nessa seção é demonstrado como retornar dados no formato \sigla{JSON}. Como exemplo é retornado um único objeto do tipo \classe{Person} para o usuário.

Para mais informações sobre como manipular dados com \lang{Javascript} e \sigla{AJAX}, é recomendada a leitura dos livros \est{Pro Javascript For Web Apps} e \est{Pro jQuery} da editora \est{Apress}.

\subsubsection{Java}

A biblioteca \est{Jackson Databind} é responsável por converter objetos \lang{Java} no formato \sigla{JSON}. Essa biblioteca foi adicionada ao projeto durante a configuração do arquivo \arquivo{build.gradle} na seção 3.1.2. 

Para uma ação retornar um objeto \sigla{JSON}, ela deve retornar um objeto \lang{Java} decorado com a anotação \annotation{@ResponseBody}, como no código do quadro~\ref{lst:16}.

\javacode{code/16.txt}{Ação no \est{Spring MVC} que retorna um objeto \sigla{JSON}}{lst:16}

Acessando a ação \metodo{getOne} pelo navegador, é obtida a resposta exposta na Figura~\ref{fig:32}.

\figura{32.png}{Resultado \sigla{JSON} no projeto \lang{Java}}{fig:32}

O atributo \est{birthDate} é enviado ao navegador como um número que pode ser usado para criar um objeto \classe{Date} do \lang{Javascript}.

\subsubsection{ASP.NET MVC}

O \est{ASP.NET MVC} pode trabalhar com objetos no formato \sigla{JSON} sem precisar de uma biblioteca de terceiros. O exemplo do quadro~\ref{lst:17} mostra uma ação que retorna um objeto \sigla{JSON}.

\sharpcode{code/17.txt}{Ação no \est{ASP.NET MVC} que retorna um objeto \sigla{JSON}}{lst:17}

O método \metodo{Json} no final da ação faz a conversão de objetos para o formato \sigla{JSON}. Por padrão o \est{ASP.NET MVC} só envia objetos \sigla{JSON} usando o método \est{HTTP POST}, para a habilitar o uso de \est{HTTP GET} é necessário um parâmetro adicional. A Figura~\ref{fig:33} mostra a resposta à ação \metodo{GetOne}.

\figura{33.png}{Resultado \sigla{JSON} no projeto \est{ASP.NET MVC}}{fig:33}

Aqui existe uma inconveniência. O modo como o \est{ASP.NET} envia datas faz com que seja necessário mais código \lang{Javascript} para extrair o número que realmente representa a data e criar um objeto \classe{Date}.

\subsection{Gerando \est{Views} Dinâmicas}

Nessa seção é demonstrado como fazer uma página que exibe todos os itens das listas de objetos \classe{Person} em ambos os projetos. São feitas ações que enviam as listas para as \est{views} que montam o código \sigla{HTML} usando as \est{view engines} padrão de cada tecnologia, \est{JSP Standart Tag Library} (\sigla{JSTL}) no projeto \est{Java/Spring} e \est{Razor} no projeto \est{ASP.NET MVC}.

\subsubsection{Java (JSTL)}

Observe o método \metodo{listPage} na classe \classe{PersonController} no exemplo do quadro~\ref{lst:18}.

\javacode{code/18.txt}{Ação no projeto \lang{Java} que retorna uma página com a lista de \classe{Persons}}{lst:18}

O tipo de retorno do método \metodo{listPage} e um objeto do tipo \classe{ModelAndView}. Esse objeto representa uma página dinâmica que pode conter e manipular objetos \lang{Java}. O método é mapeado para o endereço <raiz da aplicação>/person/list. 

A ação começa com a verificação de existência, e se for o caso criação da lista. Logo em seguida ele cria um objeto \classe{ModelAndView} que aponta para uma nova página que será criada dentro da pasta \est{person}, \arquivo{list.jsp}. O método \metodo{addObject} adiciona a lista \est{persons} para que a página possa utilizá-la com o nome de referência \est{personsList}. O Resultado então é retornado para o usuário. O quadro~\ref{lst:19} mostra o código da página \arquivo{list.jsp}.

\jspcode{code/19.txt}{Código da página \arquivo{list.jsp}}{lst:19}

A página começa com o cabeçalho padrão de páginas \est{jsp}. Logo abaixo, o cabeçalho \est{taglib} adiciona a referência à biblioteca \sigla{JSTL} básica. Essa biblioteca contém um conjunto de \est{tags} \sigla{JSTL}, pedaços de código \lang{Java} que ajudam a montar páginas dinâmicas. As \est{tags} \sigla{JSTL} são escritas na página como pedaços de código que lembram \est{tags} \lang{HTML}, mas devem começar utilizando prefixo configurado no cabeçalho \est{taglib} (no caso do exemplo acima, a letra "c"). Até o fim da \est{tag} \lang{HTML} <thead>, o que está escrito na página é apenas \lang{HTML} puro. A parte onde o \sigla{JSTL} entra em ação é dentro do corpo da tabela. 

A \est{tag} \est{forEach} cria um pedaço de bloco \lang{HTML} para cada item em uma coleção. Essa coleção é configurada no atributo \est{items} e usando a sintaxe do \sigla{JSTL} é dito que a coleção se chama \est{personList}, o mesmo nome que foi usado como referencias para passar a lista de objetos \classe{Person} para a página. O atributo \est{var} configura um nome de referência para o objeto que é usado em cada iteração da lista.

Dentro de cada iteração é criada uma nova linha para a tabela, e em cada linha é criada duas colunas, uma mostrando o atributo \est{name} e outra o \est{birthDate} do objeto \est{person}. Note que não é necessário chamar os métodos \metodo{getName} e \metodo{getBirthDate}, é necessário apenas referenciar o nome do atributo que o desenvolvedor deseja mostrar na página. Depois de adicionar alguns objetos à lista, é obtido o resultado exposto na Figura~\ref{fig:34}.

\figura{34.png}{Resultado da página \arquivo{list.jsp}}{fig:34}

O \sigla{JSTL} possui muitas outras \est{taglibs}. Para mais informações, consulte a documentação do \sigla{JSTL}.

\subsubsection{ASP.NET (Razor)}

O exemplo do quadro~\ref{lst:20} mostra a ação que retorna a página que exibe o conteúdo da lista.

\sharpcode{code/20.txt}{Ação que retorna a página \arquivo{list.cshtml}}{lst:20}

O método \metodo{View} pode receber como parâmetro qualquer objeto que o desenvolvedor queira passar para a página, aqui ele recebe a lista de objetos do tipo \classe{Person}. O quadro~\ref{lst:21} mostra o código fonte da página \arquivo{list.cshtml}.

\sharpcode{code/21.txt}{Código fonte da página \arquivo{list.cshtml}}{lst:21}

Além da sintaxe da \est{view engine Razor} (que mistura código \lang{C\#} com \lang{HTML}) uma diferença em relação à página do projeto \lang{Java} é que uma página no \est{ASP.NET MVC} pode ser fortemente tipada.

A primeira linha da página importa o \est{namespace} \pacote{NetWebCrud.Models} para se utilizar de suas classes. A segunda linha informa qual é o tipo de objeto que será o modelo da página, uma lista de objetos \classe{Person} como a que foi passada na ação do \est{controller}.

O objeto \est{Model} dentro do laço \est{foreach} é a referência ao objeto que foi enviado para a página. \est{Model} faz referência a qualquer tipo de objeto e a diretiva \est{@model} no começo da página especifica seu tipo para que os recursos de auto completar do \est{Visual Studio} estejam disponíveis e o \est{ASP.NET MVC} possa gerar a página. O resultado pode ser visto na Figura~\ref{fig:35}.

\figura{35.png}{Resultado da página \arquivo{list.cshtml}}{fig:35}

Note que o \est{ASP.NET MVC} exibe também a hora do atributo \est{BirthDate}.

\subsection{Conclusão}

Enquanto no \est{Spring MVC} o desenvolvedor deve decorar seus \est{controllers} e ações com várias anotações \annotation{@RequestMapping}, no \est{ASP.NET MVC} o mapeamento de endereços é centralizado inteiramente na tabela de rotas. Isso junto com as convenções do \est{ASP.NET MVC} ajudam o desenvolvedor a escrever menos código.

Os \est{controllers} no \est{Spring MVC} podem ser qualquer classe decorada com a anotação \annotation{@Controller}, no \est{ASP.NET MVC} devem ser classes que herdem da superclasse \classe{Controller} e tenham o sufixo \est{"Controller"} no seu nome. O modo de criação de \est{controllers} no \est{Spring MVC} é mais flexível, mas é uma boa prática também adicionar o sufixo \est{"Controller"} em tais classes e deixa-las em um pacote especifico para \est{controllers} objetivando uma melhor organização de código.

Ao enviar dados para o servidor, a única diferença significativa é o modo de enviar datas. O mapeamento dos dados da requisição \sigla{HTTP} para objetos é simples e funcional em ambas as tecnologias.

O \est{ASP.NET MVC} dá suporte nativo para manipulação de objetos no formato \sigla{JSON}, bastando apenas que o desenvolvedor utilize o método \metodo{Json} para gerar um objeto \classe{JSONResult}. O \est{Spring MVC} não vem com suporte nativo para trabalhar com objetos \sigla{JSON}, sendo necessária a biblioteca \est{Jackson Databind} e a configuração de anotações.

A \est{view engine} \sigla{JSTL} utiliza uma sintaxe parecida com o \lang{HTML}, se integrando melhor ao código da página, enquanto o \lang{Razor} tem a vantagem da possibilidade de ser fortemente tipado e utilizar as vantagens do \lang{C\#} como a função de auto completar código do \est{Visual Studio}. Em ambas as tecnologias o desenvolvedor pode estender as \est{view engines}, em projetos \lang{Java} novas \est{taglibs} podem ser criadas e no \est{ASP.NET MVC} podem ser feitas \est{View Helpers} e \est{Partial Views}. Um vantagem do \est{ASP.NET MVC} em relação ao \est{Java Enterprise Endition} em se tratando de \est{views} é o suporte nativo à \est{layouts} (também conhecidas como \est{master pages}). Caso o desenvolvedor \lang{Java} queria usar \est{layouts}, deve recorrer às bibliotecas de terceiros como o \est{Sitemesh} ou utilizar outras \est{view engines} como o \est{FreeMarker}. E aqui encontramos a maior vantagem do \est{Java Enterprise Edition} em relação à \est{views}, o desenvolvedor pode escolher simplesmente utilizar outras \est{view engines}.

No próximo capitulo são abordados a criação de classes de negócio/serviços e injeção de dependências. 

\newpage
\section{Classes de serviços e injeção de dependências}

Uma aplicação de três camadas típica se divide em camadas de apresentação, negócios/serviços e persistência de dados. A camada de serviços é onde se escreve o código que representa regras de negócio das aplicações, enquanto a camada de persistência é responsável por guardar os dados da aplicação para uso posterior. É importante que essas camadas estejam fracamente acopladas, pois o desenvolvedor pode, por exemplo, aproveitar as classes de negócio que ele escreveu para uma aplicação \est{web} em uma aplicação para celular.

Nos exemplos desse trabalho, a camada de apresentação é formada pelas páginas \est{web} escritas no capítulo anterior, os \est{controllers} funcionam como uma ponte entre a camada de apresentação e de negócios. \est{Controllers} devem apenas receber e responder requisições, o ideal é que não exista código de regras de negócios em suas ações.

Nesse capítulo é demonstrado como escrever classes de serviço (também chamadas de classes de negócio) fracamente acopladas à camada de apresentação e aos \est{controllers}. 

\subsection{Classes de serviços}

É criada como exemplo uma classe de serviço em cada projeto que contêm um método com uma regra de negócio simples. As listas de objetos \classe{Person}, até agora pertencente aos \est{controllers}, são movidas para essas classes como uma forma de representar a camada de persistência. Em ambos os projetos, o serviço implementa uma \est{interface}. Diferente do que é sugerido para \est{controllers}, que um \est{controller} não deve chamar métodos de outro, classes de serviço podem utilizar outras classes de serviço.

\subsubsection{Java}

No projeto \lang{Java}, a \est{interface} e classe concreta são criadas no pacote \pacote{br.uece.webCrud.service}. Primeiro é feita a interface \classe{PersonService} que o serviço irá implementar, como podemos observar no quadro~\ref{lst:22}.

\javacode{code/22.txt}{\est{Interface} \classe{PersonService}}{lst:22}

No quadro~\ref{lst:23} pode-se observar o serviço \classe{PersonServiceImpl} implementando a \est{interface} \classe{PersonService}.

\javacode{code/23.txt}{Classe \classe{PersonServiceImpl}}{lst:23}

A classe \classe{PersonServiceImpl} começa decorada com a anotação \annotation{@Service}. Essa anotação é usada pelo \est{Spring Framework} para marcar classes da camada de serviços. A anotação \annotation{@Service} herda da anotação \annotation{@Component}, então essa é uma classe que pode ser usada pelo \est{Spring IoC Container} durante injeção de dependências. Mais detalhes sobre injeção de dependências e o modo como o \est{Spring} injeta uma instância dessa classe serão explicados nas seções 5.2 e 5.2.1. Segundo a documentação do \est{Spring Framework 4.1.4}, a anotação \annotation{@Service} tem o mesmo efeito que \annotation{@Component}, mas é recomendado o uso de \annotation{@Service} pois em versões futuras do \est{framework}, essa anotação poderá conter funcionalidades adicionais.

O construtor de \classe{PersonServiceImpl} inicializa a lista de objetos \classe{Person}. O método \metodo{add} recebe um objeto do tipo \classe{Person} como parâmetro. Ele verifica se já existe um objeto com o mesmo nome na lista, se sim, dispara uma exceção, se não, adiciona o objeto à lista. Essa verificação é um exemplo simples de uma regra de negócios.

\subsubsection{.NET}

As classes de serviços no projeto \est{ASP.NET MVC} são criadas dentro da pasta \arquivo{Models/Services}. Para o \est{ASP.NET MVC} a camada \est{model} de uma aplicação \sigla{MVC} contém tanto entidades quanto regras de negócios. Assim como no projeto \lang{Java}, primeiro é feita a \est{interface} \classe{IPersonService} mostrada no quadro~\ref{lst:24}.

\sharpcode{code/24.txt}{\est{Interface} \classe{IPersonService}}{lst:24}

O quadro~\ref{lst:25} mostra a implementação da \est{interface} pela classe \classe{PersonService}.

\sharpcode{code/25.txt}{Classe \classe{PersonService}}{lst:25}

A classe \classe{PersonService} no projeto \est{ASP.NET MVC} é uma classe comum para onde foi movida a lista de objetos \classe{Person} e contém um método idêntico ao do projeto \lang{Java}. Nenhuma anotação ou configuração especial é feita na classe para identificá-la como serviço.

\subsection{Injeção de dependências}

Injeção de dependências é uma técnica utilizada para diminuir o acoplamento entre classes. Nos exemplos dessa seção, as classes de serviço são injetadas nos \est{controllers} criados no capitulo anterior. 

Considere o exemplo do quadro~\ref{lst:26}.

\javacode{code/26.txt}{Exemplo de classes fortemente acopladas}{lst:26}

No exemplo acima, a classe \classe{Foo} usa uma classe chamada \classe{BarImpl} que implementa uma \est{interface} chamada \classe{Bar}. Nesse exemplo a classe \classe{Foo} fica fortemente acoplada à implementação \classe{BarImpl}. Imagine se a classe \classe{BarImpl} fosse uma classe de persistência que salva informações em arquivos de texto e um dia o desenvolvedor precisasse portar a aplicação para mais um ambiente onde seria usado um banco de dados. Sem usar injeção de dependências, o desenvolvedor também teria que escrever uma nova versão da classe \classe{Foo} que usasse outra implementação de \classe{Bar}.

O exemplo do quadro~\ref{lst:27} mostra como funciona a injeção de dependências.

\javacode{code/27.txt}{Exemplo de classes fracamente acopladas}{lst:27}

No exemplo acima, a classe \classe{Foo} agora recebe em seu construtor um abjeto que implemente \classe{Bar}. Uma instância de \classe{BarImpl} é criada dentro do método \metodo{main} e injetada dentro da instância de \classe{Foo}. Nesse cenário, as classes não estão tão acopladas e o desenvolvedor pode usar outras implementações de \classe{Bar} mais facilmente. A injeção de dependências também é conhecida como inversão de controle (\est{Inversion of Control} ou \sigla{IoC}), pois dá a responsabilidade de inicializar dependências de uma classe para classes externas. 

Essa técnica ainda pode ser melhorada se a injeção de dependências for automatizada, requerendo menos código. É isso que o \est{IoC Container} do \est{Spring Framework} e o \est{Ninject} fazem. O uso dessas ferramentas será demonstrado nas seções seguintes.

\subsubsection{Java}

O \est{Spring IoC container} resolve dependências procurando por classes para serem injetadas dentro dos pacotes da aplicação de modo automático. Na seção 3.1.3., a classe de configuração \classe{SpringMvcConfig} foi decorada com a anotação \annotation{@ComponentScan}. Os nomes dos pacotes passados como parâmetro para essa anotação são os pacotes onde o \est{Spring Framework} procura por classes para serem instanciadas e injetadas.

Para serem utilizadas pelo \est{Spring IoC container}, as classes devem estar decoradas com a anotação \annotation{@Component} ou alguma de suas especializações, como \annotation{@Service}, \annotation{@Repository} e \annotation{@Controller} ou métodos decorados com a anotação \annotation{@Bean}. Por padrão o \est{Spring IoC container} injeta as classes como \est{singletons}, criando apenas uma instância da classe para ser usada várias vezes. Esse comportamento pode ser alterado pela anotação \annotation{@Scope} nas classes que se deseja injetar.

A diferença entre as anotações \annotation{@Component} e \annotation{@Bean} (também utilizada na seção 3.1.3) é que \annotation{@Component} é usado em classes que o próprio \est{Spring IoC container} procura e instancia enquanto \annotation{@Bean} é usado em métodos que retornam objetos que o próprio desenvolvedor criou. Classes anotadas com \annotation{@Component} ou uma de suas especializações devem ter um construtor que não receba parâmetros.

O código do quadro~\ref{lst:28} mostra uma nova versão do \est{controller} \classe{PersonController} do projeto \est{Java/Spring}, agora com uma instância de \classe{PersonServiceImpl} sendo injetada e utilizada.

\javacode{code/28.txt}{\classe{PersonController} utilizando \classe{PersonService} no projeto \est{Java/Spring}}{lst:28}

No lugar da lista em memória, agora o \est{controller} possui e utiliza um \classe{PersonService} que  está decorado com a anotação \annotation{@Autowired}. Essa anotação marca propriedades onde o \est{Spring IoC container} deve injetar dependências. No caso acima, o \est{container} procura por classes decoradas com \annotation{@Component} ou suas especializações, que implementam \classe{PersonService} e estão contidas nos pacotes configurados por \annotation{@ComponentScan}. Encontrada a classe \classe{PersonServiceImpl}, uma instância dessa classe é criada e atribuída à propriedade \est{personService} para uso no \classe{PersonController}.

Essa não é a única maneira de injetar dependências usando o \est{Spring}. Para conhecer mais opções de injeção de dependências, aconselha-se consultar sua documentação.

\subsubsection{.NET}

O \est{ASP.NET MVC 5} não possui injeção de dependências automática nativa, então é usado a biblioteca \est{Ninject} para essa funcionalidade. Diferente do \est{Spring}, o \est{Ninject} não procura por classes de modo automático para injetar dependências, as classes que o desenvolvedor deseja injetar devem ser configuradas por código. Na seção 3.2.1, o \est{Ninject MVC 5} foi adicionado ao projeto e uma classe chamada \classe{NinjectWebCommon} (exibida no quadro~\ref{lst:29}) foi criada na pasta \arquivo{App\_Start}. 

\sharpcode{code/29.txt}{Classe \classe{NinjectWebCommon}}{lst:29}

O método \metodo{Start} é executado quando a aplicação é inicializada, ele registra módulos do \est{Ninjet} para uso interno da aplicação, cria e inicializa um \est{kernel} do \est{Ninject}. O \est{kernel} é o objeto onde é feita a configuração de injeções de dependência, essa configuração é feita no método \metodo{RegisterServices} como mostra o quadro~\ref{lst:30}.

\sharpcode{code/30.txt}{Registro de dependências no \est{Ninject}}{lst:30}

O \est{kernel} do \est{Ninject} pode usar uma sintaxe fluente para configurar dependências. Aqui usa-se o método genérico \metodo{Bind} recebendo a interface \classe{IPersonService} seguido do método \metodo{To} configurando a classe \classe{PersonService} para ser a classe concreta injetada quando o \est{Ninject} encontra aquela interface. Por último, o método \metodo{InRequestScope} cria uma instancia de \classe{PersonService} para cada requisição do usuário ao servidor. Existe o método \metodo{InSingletonScope} que pode criar apenas uma instancia da classe para todos os usuários e todas as requisições, mas a necessidade de se utilizar \metodo{InRequestScope} é abordada na seção 6.3.2.

O \est{Ninject} é uma biblioteca extensa que contém módulos que funcionam em vários tipos de projetos \sigla{.NET}. Para mais informações aconselha-se acessar a página do \est{Ninject} (\url{http://www.ninject.org/}).

O \est{controller} \classe{PersonController} é modificado para utilizar o serviço \classe{PersonService}, como pode ser observado no quadro ~\ref{lst:31}.

\sharpcode{code/31.txt}{\classe{PersonController} do projeto \est{ASP.NET MVC} usando \classe{PersonService}}{lst:31}

A anotação \annotation{Inject} decora a propriedade \classe{PersonService} onde é injetada a instância de classe \classe{PersonService}, do mesmo modo que \annotation{@Autowired} no projeto \est{Java/Spring}. A propriedade deve ter um método \metodo{set} público para que o \est{Ninject} possa ter acesso e injetar a classe concreta, o método \metodo{get} pode ser mais restrito.

\subsection{Conclusão}

O \est{Spring} possui a anotação \annotation{@Service} para marcar classes de serviço e classes de negócio, enquanto no \est{ASP.NET MVC} qualquer classe pode ser uma classe de serviço. Atualmente nenhuma das tecnologias mostra vantagem na criação de serviços mas no futuro, talvez sejam adicionadas funcionalidades para a anotação \annotation{@Service} que possam beneficiar o \est{Spring Framework}.

O \est{Spring} é superior ao \est{ASP.NET MVC 5} em se tratando de injeção de dependências. Além de ter um \est{IoC container} nativo, o \est{Spring} resolve dependências automaticamente enquanto o \est{ASP.NET MVC 5} precisa de bibliotecas de terceiros, e o \est{Ninject} precisa de configurações via código para todas as classes que são injetadas.

Na próxima versão do \sigla{ASP.NET}, também chamada de \est{vNext}, será adicionado um \est{IoC Container} nativo. Até o momento em que este trabalho está sendo escrito, o \est{vNext} está em fase de testes público e pode passar por mudanças, então o uso do \est{IoC Container} da próxima versão não foi considerado.

No próximo capítulo é abordada a criação do banco de dados a partir de entidades de negócio e acesso a dados usando repositórios do \est{Spring} e a classe \classe{DbContext} do \est{Entity Framework}.

\newpage
\section{Entidades e repositórios}

Entidades são classes que representam os objetos de negócio, a classe \classe{Person} utilizada até agora é um exemplo de entidade. Em ambos os projetos, essa classe é usada para gerar uma tabela no banco de dados e substituir as listas em memória que foram usadas até então. Essa técnica é chamada de mapeamento objeto/relacional, pois mapeia propriedades de objetos para tabelas e colunas no banco de dados relacional. Nos exemplos desse capitulo são usados o \est{Hibernate} no projeto \est{Java/Spring} e o \est{Entity Framework} no projeto \est{ASP.NET MVC} como bibliotecas para mapeamento objeto/relacional.

Além de a classe \classe{Person}, nesse capitulo é criada a classe \classe{Contact} que conterá o \est{e-mail} e o telefone de uma pessoa. Essa classe terá um relacionamento de um para um com a classe \classe{Person} e irá gerar uma chave estrangeira no banco de dados.

Com as entidades prontas, são feitos repositórios para persisti-las no banco de dados. Será feito um repositório genérico e um repositório especifico para cada classe.

\subsection{Entidades}

As seções a seguir mostram como utilizar uma classe para gerar tabelas no banco de dados. Entidades precisam de um identificador único para ser sua chave primária, essa propriedade será chamada \est{Id} e será do tipo inteiro.

Como são usadas duas entidades nesse capitulo e ambas precisam do identificador único, é criada uma classe base com essa propriedade em comum chamada \classe{BaseEntity}. O intuito da criação dessa classe é mostrar como é possível o uso de herança nas entidades. As classes \classe{Person} e \classe{Contact} são especializações de \classe{BaseEntity}.

\subsubsection{Java}

Entidades no projeto \est{Java/Spring} são criadas no pacote \pacote{br.uece.webCrud.model}. A classe \classe{BaseEntity} é criada como mostra o quadro~\ref{lst:32}.

\javacode{code/32.txt}{Classe \classe{BaseEntity} no projeto \lang{Java}}{lst:32}

A classe \classe{BaseEntity} é decorada com a anotação \annotation{@MappedSuperclass} que diz ao \est{Hibernate} que entidades que sejam suas subclasses devem levar em consideração as propriedades herdadas no mapeamento objeto/relacional. A propriedade \est{id} é decorada com as anotações \annotation{@Id}, que configura o \est{Hibernate} para usá-la como chave primária e única, e \annotation{@GeneratedValue}, que delega ao banco de dados a lógica de geração do valor da chave.

A classe \classe{Person} então é modificada como no quadro~\ref{lst:33}.

\javacode{code/33.txt}{Classe \classe{Person} herda de \classe{BaseEntity}}{lst:33}

A classe \classe{Person} agora é subclasse de \classe{BaseEntity} e está decorada com a anotação \annotation{@Entity}. A anotação \annotation{@Entity} diz ao \est{Hibernate} que essa classe deve ser mapeada para uma tabela e as propriedades da classe para as colunas da tabela.

Por padrão o \est{Hibernate} procura por uma tabela com o mesmo nome da classe e colunas com o mesmo nome das propriedades para realizar o mapeamento, mas esse comportamento pode ser modificado com as anotações \annotation{@Table}, \annotation{@Column}, \annotation{@Transient} e muitas outras. A propriedade \est{name} por exemplo, está decorada com a anotação \annotation{@Column} especificando que aquela propriedade não pode ser nula no banco de dados e a propriedade \est{birthDate} está decorada com a anotação \annotation{@Temporal} especificando que a coluna no banco deve ser do tipo \classe{Date}.

Na seção 3.1.3, durante a configuração do projeto, a propriedade \est{hibernate.hbm2ddl.auto} foi configurada com o valor \est{"create"}, assim o \est{Hibernate} cria as tabelas no banco de dados de acordo com as configurações de classes decoradas com a anotação \annotation{@Entity}. Outros valores para essa configuração podem ser \est{"update"}, para atualizar a estrutura das tabelas sem perder dados, e \est{"validate"}, para apenas verificar se o mapeamento objeto/relacional está consistente. O \est{Hibernate} cria tabelas, mas não cria o banco de dados, para que a criação de tabelas funcione é necessário que o banco de dados já exista. As tabelas são criadas no momento em que a aplicação é iniciada.

\subsubsection{.NET}

Entidades no projeto ASP.NET MVC são criadas na pasta \arquivo{Model/Entities}. Considere que a classe \classe{Person} é movida para essa pasta. O quadro~\ref{lst:34} mostra a classe \classe{BaseEntity} do projeto \est{ASP.NET MVC}.

\javacode{code/34.txt}{Classe \classe{BaseEntity} no projeto \est{ASP.NET}}{lst:34}

Uma convenção do \est{Entity Framework} é que se uma classe tiver uma propriedade chamada \est{Id} de tipo numérico ou \est{guid} (tipo de identificar único), essa propriedade será usada como chave primária. Assim nenhuma configuração adicional é necessária.

Assim como no projeto \lang{Java}, a classe \classe{Person} do projeto \est{ASP.NET MVC} é modificada para ser subclasse de \classe{BaseEntity}, como mostrado no quadro~\ref{lst:35}.

\javacode{code/35.txt}{Classe \classe{Person} no projeto \est{ASP.NET} agora herda de \classe{BaseEntity}}{lst:35}

Assim como no projeto \lang{Java}, entidades do \est{Entity Framework} podem ser decoradas com anotações que controlam como as tabelas serão geradas. No exemplo acima a anotação \annotation{Required} também diz que a coluna correspondente à propriedade \est{Name} não pode aceitar valores nulos.

\paragraph{Criando o contexto do banco de dados}

Não existe configuração nas classe do projeto \est{ASP.NET MVC} que indique que elas são entidades e que devem ser usadas no mapeamento objeto/relacional. Esse papel é da classe \classe{DbContext} do \est{Entity Framework}. A classe \classe{DbContext} representa o banco de dados como um todo. Para criar o banco de dados a partir das entidades, o desenvolvedor deve criar uma classe que herde de \classe{DbContext} e tenha propriedades do tipo \classe{DbSet} como a classe \classe{NetWebCrudContext} no exemplo do quadro~\ref{lst:36}. 

\sharpcode{code/36.txt}{Classe \classe{NetWebCrudContext} representa o contexto do banco de dados}{lst:36}

A classe \classe{NetWebCrudContext} possui um \classe{DbSet} de objetos do tipo \classe{Person} que representa a tabela que é gerada no banco de dados. Para utilizar o banco, o desenvolvedor deve criar uma instância do contexto e fazer consultas aos \classe{DbSets} usando o Language Integrated Query (\lang{LINQ}). O \lang{LINQ} é uma linguagem para realizar consultas em coleções do \est{.NET Framework}. Usado em \classe{DbSets}, ele gera consultas \lang{SQL} automaticamente para manipular o banco de dados. Consultas com \lang{LINQ} são abordadas na seção 6.4.

O construtor de \classe{NetWebCrudContext} executa o construtor de \classe{DbContext} recebendo como parâmetro o nome da \est{connection string} que contém informações de conexão com o banco. Ele recebe o nome da \est{connection string} \est{NetWebCrudContext}, a mesma que foi configurada no arquivo \arquivo{Web.xml} na seção 3.2.2.

O construtor do contexto do banco de dados também é usado para configurar o tipo de inicialização do banco. O construtor de \classe{NetWebCrudContext} utiliza como inicializador a classe \classe{DropCreateDatabaseIfModelChanges}, então se qualquer entidade for modificada, o banco de dados é totalmente reconstruído e todos os dados perdidos. Existem outras classes que podem ser usadas como inicializadores como \classe{CreateDatabaseIfNotExists}, para criar o banco apenas uma vez, e \classe{DropCreateDatabaseAways} para sempre recriar o banco de dados quando a aplicação iniciar. O desenvolvedor pode estender esses inicializadores ou construir um completamente novo que implemente a interface \classe{IDatabaseInitializer}.

O \est{Entity Framework} não atualiza automaticamente a estrutura do banco de dados sem perder informações, para isso é necessário utilizar o \est{Entity Framework Migrations}. Essa funcionalidade permite utilizar as linguagens \lang{C\#} ou \lang{VB.NET} para executar \est{scripts} no banco de dados e atualizar sua estrutura. O \est{Entity Framework Migrations} não é abordado nesse trabalho, para mais informações recomenda-se consultar a documentação do \est{Entity Framework}.

O método \metodo{OnModelCreating} é usado para configurar diversos aspectos da criação do banco de dados.  No exemplo do quadro~\ref{lst:36}, a convenção de pluralizar o nome das tabelas é removida.

Diferente do \est{Hibernate} que cria ou atualiza o banco de dados quando a aplicação é iniciada, o \est{Entity Framework} cria o banco de dados na primeira vez em que uma instancia de \classe{DbContext} é criada.

Uma instancia de \classe{NetWebCrudContext} precisa ser instanciada para que se possa usar o banco de dados. No projeto exemplo, cada requisição de um usuário deve criar uma nova instancia de \classe{NetWebCrudContext}. Se mais de um usuário utilizar a mesma instancia, poderão haver erros de concorrência e um usuário poderá ter acesso os dados de outro que ainda não foram salvos para o banco de dados. O \est{Ninject} é responsável por criar as instancias de \classe{NetWebCrudContext} e injeta-las nos repositórios que serão criados na seção 6.3.2. O quadro~\ref{lst:37} mostra a configuração de injeção de \classe{NetWebCrudContext}.

\sharpcode{code/37.txt}{Injeção do contexto do banco de dados}{lst:37}

\subsection{Relacionamentos entre entidades}

Entidades podem se relacionar com outras com o uso de chaves estrangeiras. O relacionamento entre a classe \classe{Person} e a classe \classe{Contact} é usado nos exemplos dessa seção.

\subsubsection{Java}

A classe \classe{Contact} é criada no pacote \pacote{br.uece.webCrud.model} como mostra o quadro~\ref{lst:38}.

\javacode{code/38.txt}{Classe Contact no projeto Java}{lst:38}

Assim como a classe \classe{Person}, a classe \classe{Contact} herda de \classe{BaseEntity} e é decorada com a anotação \annotation{@Entity}. O Relacionamento com a classe \classe{Person} é configurado pela anotação \annotation{@OneToOne} decorando o atributo \est{person}. O atributo \est{mappedBy} recebendo o valor \est{"contact"} quer dizer que na classe \classe{Person} deve existir um atributo com esse nome, configurado como o dono do relacionamento entre as tabelas. Resumindo, a tabela correspondente à classe \classe{Person} deve ter a coluna com a chave estrangeira para \classe{Contact}.

Além da anotação \annotation{@OneToOne}, o \sigla{JPA} possui as anotações \annotation{@OneToMany}, \annotation{@ManyToOne} e \annotation{@ManyToMany} para criar relacionamentos. As anotações \annotation{@OneToMany} e \annotation{@ManyToMany} devem ser usadas em uma coleção de objetos, quando uma entidade tem um relacionamento de "um para muitos" ou de "muitos para muitos" com outra entidade.

O relacionamento na classe \classe{Person} também deve ser configurado como mostra o quadro~\ref{lst:39}.

\javacode{code/39.txt}{Classe \classe{Person} com relacionamento para \classe{Contact}}{lst:39}

A classe \classe{Person} agora possui uma propriedade do tipo \classe{Contact}, também decorada com a anotação \annotation{@OneToOne} e com a anotação \annotation{@JoinColumn}. A primeira anotação é configurada para cascatear todas as operações de \classe{Person} para \classe{Contact}. Se por exemplo, um objeto do tipo \classe{Person} for atualizado no banco de dados, a sua propriedade \est{contact} também será atualizada. A configuração \est{fetch} recebe como valor \classe{FetchType.EAGER}, configurando a propriedade \est{contact} para ser recuperada do banco de dados por \est{eager loading} (executando uma única consulta). A propriedade \est{fetch} também pode receber \classe{FetchType.LAZY}, fazendo com que \est{contact} só seja carregado quando necessário, mas gerando uma nova consulta ao banco de dados.

A anotação \annotation{@JoinColumn} configura a classe \classe{Person} para criar a coluna da chave estrangeira na sua tabela correspondente, essa coluna tem o nome de \est{contactId}. O \est{Hibernate} detecta automaticamente as chaves decoradas com \annotation{@Id} e as utiliza como chaves estrangeiras em tabelas relacionadas. A Figura~\ref{fig:36} mostra o resultado de criação das tabelas no banco de dados \est{MySQL}. 

\figura{36.png}{Tabelas geradas pelo \est{Hibernate}}{fig:36}

\subsubsection{.NET}

A classe \classe{Contact}, ilustrada no quadro~\ref{lst:40}, também é criada no projeto \est{ASP.NET MVC}.

\sharpcode{code/40.txt}{Classe \classe{Contact} no projeto \est{ASP.NET MVC}}{lst:40}

A classe \classe{Contact} não requer nenhuma configuração, sendo apenas preciso herdar de \classe{BaseEntity} para adquirir a propriedade \est{Id}. Por outro lado, a classe \classe{Person} recebe mais propriedades como mostra o quadro~\ref{lst:41}.

\sharpcode{code/41.txt}{Classe \classe{Person} no projeto \est{ASP.NET} com novas propriedades}{lst:41}

Na classe \classe{Person} é adicionada uma propriedade \classe{Contact} modificada com a palavra chave \est{"virtual"} para configurá-la como uma propriedade de navegação que pode ser carregada por \est{lazy loading}. Isso resulta em mais uma consulta no banco, mas com o uso do \lang{LINQ} é possível recuperar as informações de \classe{Person} e \classe{Contact} com apenas uma consulta.

A propriedade \est{ContactId} gera a coluna da chave estrangeira. Por convenção do \est{Entity Framework}, propriedades de chaves estrangeiras devem ter o nome da propriedade de navegação (\classe{Contact}) seguido do nome da sua chave primária (\est{Id}).

Por último, é necessário adicionar um \classe{DbSet} para \classe{Contact} no contexto do banco de dados, como mostra o quadro~\ref{lst:42}.

\sharpcode{code/42.txt}{Classe \classe{NetWebCrudContext} com o \classe{DbSet} para \classe{Contact}}{lst:42}

O resultado no banco é semelhante ao do projeto \est{Java/Spring}, como mostra a Figura~\ref{fig:37}. Uma diferença que deve ser ressaltada é a criação da tabela \est{\_\_migrationhistory}. Essa tabela é usada pelo \est{Entity Framework} para armazenar dados sobre o histórico da estrutura do banco de dados. Assim o \est{Entity Framework Migrations} sabe quais modificações devem ser feitas no banco quando as entidades são modificadas.

\figura{37.png}{Tabelas geradas pelo \est{Entity Framework}}{fig:37}

\subsection{Repositórios}

A persistência e acesso aos dados são feitos utilizando o padrão de repositórios. Em cada projeto é criado um repositório genérico, que pode realizar operações básicas (salvar, atualizar, recuperar e apagar) em qualquer classe que seja subclasse de \classe{BaseEntity}. Um repositório especifico para a entidade \classe{Person} é criado nos dois projetos e outro para \classe{Contact} apenas no projeto \est{ASP.NET MVC}. Eles são especializações do repositório genérico e possuem operações especificas para essas entidades.

É demonstrado como utilizar a \est{Java Persistence Query Language} (\lang{JPQL}) e a \est{Language Integrated Query} (\sigla{LINQ}) para realizar consultas ao banco de dados e como gerenciar transações. Por último, os repositórios são injetados nas classes de serviço, substituindo as listas em memória.

\subsubsection{Java}

Nos exemplos dessa seção, os repositórios e interfaces que eles implementam no projeto \est{Java/Spring} são criados no pacote \pacote{br.uece.webCrud.repositories}.

Primeiramente, são criadas a interface \classe{GenericRepository} e a classe \classe{GenericRepositoryImpl}, demonstradas nos quadros~\ref{lst:43} e~\ref{lst:44} respectivamente. Essa classe é o repositório genérico mencionado anteriormente.

\javacode{code/43.txt}{Interface GenericRepository}{lst:43}

\javacode{code/44.txt}{Classe GenericRepositoryImpl}{lst:44}

A classe \classe{GenericRepositoryImpl} é decorada com a anotação \annotation{@Repository}, então instâncias dela podem ser injetadas pelo \est{Spring IoC Container}. Erros de seus métodos em tempo de execução, dispararam a exceção \classe{DataAccessException} do \est{Spring Framework}.

Essa classe faz uso de \est{Java Generics}, podendo realizar suas operações com qualquer classe que herde de \classe{BaseEntity}. Seu construtor de extrai o tipo da classe com a qual ele está trabalhando a utiliza em suas operações. \classe{GenericRepositoryImpl} é uma classe abstrata (que não pode ser instanciada), quem efetivamente poderá executar suas operações serão os repositórios que herdarão dessa classe.

O objeto da classe que executa as operações no banco de dados é do tipo \classe{EntityManager}, decorado com a anotação \annotation{@PersistenceContext}. A instancia de \classe{EntityManager} é criada pelo \est{bean} \classe{LocalContainerEntitityManagerFactoryBean}, configurado na seção 3.1.3, e injetado pelo \est{Spring IoC Container}. Para objetos de acesso a dados, a anotação \annotation{@PersistenceContext} funciona do mesmo modo que \annotation{@Autowired}.

O método \metodo{getAll} retorna todas as entradas de uma determinada entidade armazenada no banco de dados. Ele mostra um exemplo de como criar uma consulta usando o método \metodo{createQuery} de \classe{EntityManager}, recebendo o texto da consulta escrito em \lang{JPQL}. Essa linguagem possui similaridades com \lang{SQL}. O método \metodo{getResultList} executa a consulta criada, convertendo o texto \lang{JPQL} em \lang{SQL}, realizando a consulta no banco de dados, mapeando tuplas para objetos, e devolvendo o resultado como uma lista. Para mais informações sobre o \lang{JPQL}, é recomendado consultar a documentação da linguagem no site \url{http://docs.oracle.com/cd/E15523_01/apirefs.1111/e13946/ejb3_langref.html}.

O método \metodo{findById} usa o método \metodo{find} do \classe{EntityManager} para encontrar uma entidade com chave primária e do tipo que foram passados como parâmetros. O método \metodo{add} chama o método \metodo{persists} para inserir um novo objeto no banco de dados. Esse objeto não pode ter uma chave primária de valor já existente no banco, ou o \est{Hibernate} irá disparar uma exceção \classe{PersistenceException}.

O método \metodo{merge}, chamado por \metodo{update}, realiza atualização dos valores de uma entidade no banco de dados. Para que ele funcione é necessário que a chave primária do objeto a ser atualizado exista, ou o \est{Hibernate} também disparará uma exceção. O método \metodo{delete}, usa \metodo{getById} para recuperar uma entidade pela sua chave primária e chama o método \metodo{remove} de \classe{EntityManager} para remove-la do banco de dados.

Com o repositório genérico criado, é possível criar um repositório especifico para a classe \classe{Person}, como mostram os quadros~\ref{lst:45} e~\ref{lst:46}. A classe \classe{PersonRepositoryImpl} adiciona o método \metodo{existsWithName}, que verifica a existência de uma pessoa com um certo nome. Nesse método é criada uma consulta mais complexa, que retorna o valor booleano \est{true}, se existir uma entidade no banco de dados com a propriedade \est{name} igual a passada como parâmetro e propriedade \est{id} diferente da passada como parâmetro. Esse exemplo também mostra como adicionar parâmetros às consultas, utilizando método \metodo{setParameter}.

\javacode{code/45.txt}{Interface PersonRepository}{lst:45}

\javacode{code/46.txt}{Classe PersonRepositoryImpl}{lst:46}

Por último, a lista em memória da classe \classe{PersonServiceImpl} é substituída por \classe{PersonRepository} e a anotação \annotation{@Transactional} é adicionada à classe, como mostra o quadro~\ref{lst:47}.

\javacode{code/47.txt}{\classe{PersonServiceImpl} utilizando \classe{PersonRepository}}{lst:47}

A anotação \annotation{@Transactional} do \est{Spring Framework} pode ser utilizada em classes ou métodos. Essa anotação configura o gerenciamento de transações com o banco de dados. Decorando um método, essa anotação faz com que uma única transação seja usada em todas as operações de acesso a dados dentro daquele método. Decorando uma classe, como no exemplo do quadro~\ref{lst:47}, a anotação aplica o seu efeito a todos os métodos da classe.  O \est{Spring} controla internamente a criação e reutilização de transações já existentes usando o \est{bean} \classe{JpaTransactionManager} também configurado na seção 3.1.3. Se um método decorado com essa anotação for chamado internamente por outro também decorado com ela, o método interno irá aproveitar a transação que já existe e não irá criar uma nova. Esse comportamento padrão pode ser modificado configurando atributos da anotação. 

Caso não ocorram erros nas operações com o banco de dados, as operações da transação são persistidas de forma atômica. Caso haja algum erro, as operações são revertidas e uma exceção é disparada. De toda forma, a transação é destruída automaticamente quando não é mais utilizada.

Como o relacionamento de \classe{Person} com \classe{Contact} configurado com \est{CascadeType.ALL} na seção 6.2.1, quando um objeto do tipo \classe{Person} é salvo ou atualizado no banco de dados, o seu contato também é. Então nos exemplos desse capitulo para \lang{Java}, não houve a necessidade de se criar um repositório para a classe \classe{Contact}.

\subsection{.NET}

Os repositórios no projeto \est{ASP.NET MVC} são criados na pasta \arquivo{Models/Repositories}. Assim como no projeto \est{Java/Spring}, começa-se criando o repositório genérico e sua \est{interface}. O quadro~\ref{lst:48} mostra a \est{interface} do repositório genérico, \classe{IGenericRepository}, e o quadro~\ref{lst:49} mostra sua implementação, \classe{GenericRepository}.

\sharpcode{code/48.txt}{\est{Interface} \classe{IGenericRepository}}{lst:48}

\sharpcode{code/49.txt}{Classe \classe{GenericRepository}}{lst:49}

Assim como no projeto \est{Java/Spring}, o repositório genérico é uma classe abstrata que realiza operações no banco de dados para classes que herdam de \classe{BaseEntity}. Também semelhante ao outro projeto, existe uma propriedade no repositório que efetivamente irá persistir dados e consultar o banco, a propriedade \est{context} do tipo \classe{NetWebCrudContext}. A propriedade \est{EntitySet} é usada para facilitar o acesso ao \classe{DbSet} correto da entidade a qual o repositório genérico irá manipular.

O método \metodo{GetById} mostra um exemplo de como se usar expressões \est{lambda} e a sintaxe fluente do \lang{LINQ} para realizar uma consulta. Métodos de filtragem e ordenação da sintaxe fluente do \lang{LINQ} retornam coleções do tipo \classe{IQueryable}, essa \est{interface} permite que mais métodos sejam chamados em cascata para a criação de consultas complexas. Uma consulta do \lang{LINQ} só é realmente executada no bando de dados quando se chamam certo métodos, como \metodo{Single}, \metodo{First}, \metodo{ToList} e \metodo{ToArray}, e essas consultas também são transformadas em \est{scripts} \lang{SQL} quando são executadas no banco de dados. No método \metodo{GetAll}, o método \metodo{ToList} do \classe{DbSet} retorna todas as tuplas do banco de dados transformadas em uma lista de objetos.

Dentro do método \metodo{Save}, um objeto é adicionado ao \classe{DbSet} usando o método \metodo{Add}, equivalente a uma operação de inserção na tabela. Operações de inserção, atualização e deleção de dados só são persistidas após a chamada do método \metodo{SaveChanges} do contexto. Esse método cria uma transação que em caso de erro reverte a transação e dispara uma exceção. É possível ter um controle melhor sobre transações, como ainda será visto nessa seção.

O método \metodo{Update} é um pouco mais complexo. Para persistir dados atualizados de uma entidade no banco de dados, caso a entidade não esteja anexada ao contexto, é necessário anexa-la e utilizar o contexto para modificar seu estado para \classe{Modfied}. Assim, quando \metodo{SaveChanges} for chamado, o contexto saberá que aquela entidade é de um objeto que já existe no banco de dados (através da chave primária já existente) e irá atualizar suas informações.

O método \metodo{Delete} é bastante similar ao do repositório do projeto \est{Java/Spring}. Uma entidade é recuperada pela sua chave primária e o método \metodo{Remove} do \classe{DbSet} a remove do banco de dados.

O método \metodo{GetTransaction} proporciona um melhor controle sobre transações. O controle automático de transações que o \est{Entity Framework} possui no método \metodo{SaveChanges} pode não ser suficiente para conversações extensas com o banco de dados em regras de negócio complexas. Então é possível criar uma transação manualmente, com o método \metodo{BeginTransation}, e utilizar essa transação para persistir ou reverter alterações. Mesmo com o uso dessa transação, e necessário chamar o método \metodo{SaveChanges} antes executar a persistência de dados.

Os repositórios para as entidades \classe{Person} e \classe{Contact} são criados como mostram os quadros~\ref{lst:50} e ~\ref{lst:51}. O \est{Entity Framework} cascateia automaticamente operações de inserção e deleção entre entidades relacionadas, mas não de atualização. Sendo assim, é necessária a existência de repositório de \classe{Contact} para que atualizações dessa entidade sejam persistidas.

\sharpcode{code/50.txt}{\est{Interfaces} \classe{IPersonRepository} e \classe{IContactRepository}}{lst:50}

\sharpcode{code/51.txt}{Classes \classe{PersonRepository} e \classe{ContactRepository}}{lst:51}

Assim como no projeto \est{Java/Spring}, o repositório para a classe \classe{Person} possui um método que verifica a existência de uma outra entidade que possua o mesmo nome. A consulta é feita com uma expressão \est{lambda} do \lang{LINQ}. O repositório para \classe{Contact} não possui nenhuma operação adicional, usa apenas as operações herdades de \classe{GenericRepository}. Como esses repositórios também serão injetados na classe de serviço \classe{PersonService}, sua configuração de injeção é adicionada à classe \classe{NinjectWebCommon}, como mostra o quadro~\ref{lst:52}.

\sharpcode{code/52.txt}{Configuração de injeção de repositórios no projeto \est{ASP.NET MVC}}{lst:52}

Por último, a classe de serviço \classe{PersonService} é atualizada como no quadro~\ref{lst:53}. O método \metodo{Update} mostra como fazer controle manual de transações. Chamando o método \metodo{GetTransaction} de \classe{PersonRepository}, ou de qualquer outro repositório, uma transação é criada para o contexto \classe{NetWebCrudContext} que é injetado no escopo da requisição do usuário. Dessa forma, só existe uma instância do contexto do banco de dados sendo utilizada por todos os repositórios, então a transação também é única.

Usando uma transação dessa forma, o desenvolvedor pode fazer as operações que desejar com quaisquer repositórios, e chamar o método \metodo{Commit} da transação para finalizar a persistência. Em caso de erros, é chamado o método \metodo{Rollback} para reverter às alterações no banco de dados. Como a transação está dentro do escopo da palavra chave \est{using}, o coletor de lixo do \est{.NET Framework} se encarrega de chamar o método \metodo{Dispose} automaticamente para finalizar a transação.

\sharpcode{code/53.txt}{Classe \classe{PersonService} utilizando ambos os repositórios no projeto \est{ASP.NET MVC}}{lst:53}

\subsection{Conclusão}

A criação de entidades para o modelo objeto/relacional com \est{Hibernate} e \est{Entity Framework} possuem abordagens distintas. No primeiro, classes precisam de anotações para serem tratadas como entidades, e no segundo não há essa necessidade. No \est{Entity Framework}, classes mais simples podem ser usadas e convenções cuidam de lógica no mapeamento objeto/relacional. A desvantagem do uso do \est{Entity Framework} é a necessidade de criação de uma classe de contexto que representa o banco de dados. Dependendo da complexidade da aplicação, a codificação e manutenção da classe de contexto pode se tornar uma inconveniência.

O relacionamento entre entidades no \est{Hibernate} é feito com anotações na própria entidade, e a configuração de relacionamentos de muito para muitos, por exemplo, pode se tornar complicada de entender para um desenvolvedor iniciante. O \est{Entity Framework} abstrai essa configuração, sendo apenas necessária a criação de propriedades de navegação entre entidades e propriedades que representem chaves estrangeiras.

Repositórios em projetos \est{Spring} com \est{Hibernate} utilizam uma implementação de \classe{EntityManager} para manipular entidades, podendo usar \est{Criteria Queries} ou \lang{JPQL} para gerar consultas. \est{Criteria Queries} utilizam vários métodos para gerar uma consulta, que no fim resulta em um código complexo, de baixa legibilidade e de manutenção questionável. A linguagem \lang{JPQL} se assemelha a \lang{SQL} e é mais legível, mas tem a desvantagem de ser escrita com \est{strings}, o que a torna mais propensa a erros. Em projetos com o \est{Entity Framework}, a linguagem \lang{LINQ} é usada para gerar consultas. Essa linguagem é de fácil entendimento, e pode utilizar as vantagens do \est{IntelliSense} (ferramenta de auto completar código do \est{Visual Studio}), tornando a detecção de erros mais fácil e a escrita de código mais eficiente.

Quanto ao controle de transações, o modo automático como o \est{Spring Framework} lida com transações o tornam uma melhor opção nesse aspecto do que o \est{Entity Framework}. 

\newpage
\section{Conclusão}

Nesse trabalho foi comparada a criação de uma aplicação \est{web} utilizando as tecnologias \lang{Java} com o \est{Spring MVC} e o \est{Hibernate}, e o \est{ASP.NET MVC} utilizando \lang{C\#}. Foram abordadas a configuração do ambiente de desenvolvimento, configuração inicial de projeto e a criação das três camadas da aplicação, apresentação (subdividida entre \est{controllers} e \est{views}), serviços (incluindo injeção de dependências) e persistência.

As conclusões a que se chegaram por esse trabalho em relação ao tópicos abordados foram as seguintes:

\begin{itemize}
  \item Preparação do ambiente de desenvolvimento - A tecnologia \sigla{.NET} é mais prática e poupa tempo do desenvolvedor. Enquanto com o \sigla{.NET} o necessário para a criação de um projeto se encontra pronto para uso em um único instalador, utilizando a tecnologia \lang{Java} o desenvolvedor deve adquirir vários \est{softwares} de fontes diferentes e configura-los.
  \item Criação e configuração de um novo projeto - Aqui a tecnologia \sigla{.NET} também obteve vantagem. Os modelos de projeto \est{ASP.NET MVC} do \est{Visual Studio} e convenções adotadas, ajudam o desenvolvedor à escrever sua aplicação imediatamente. Com o \est{Spring Framework} é necessária configuração de diversos objetos da estrutura da aplicação.
  \item Criação de \est{controllers} - Na criação de \est{controllers} em si, nenhuma tecnologia mostrou grande superioridade. Mas o \est{ASP.NET MVC} demonstrou maior praticidade no mapeamento de endereços para ações, centralizando essa configuração em um único lugar e, vez de anotações espalhadas pelo código como no \est{Spring Framework}.
  \item Criação de \est{views} - A possibilidade de \est{views} fortemente tipadas e utilização de funcionalidades de auto completar código, deram vantagem à \est{view engine Razor} do \est{ASP.NET MVC} em relação ao \sigla{JSTL} do \est{Java Enterprise Edition}. Mas seria injusto não mencionar que a liberdade de escolher outras \est{view engines} é uma grande vantagem da plataforma \lang{Java}.
  \item Criação de classes de serviço - Nenhuma tecnologia se mostrou superior à outra em relação a criação de classes de serviço.
  \item Configuração de injeção de dependências - A existência de um \est{container} nativo de injeção de dependências no \est{Spring Framework}, junto com configuração automática de instanciação e injeção de classes mostram superioridade dessa tecnologia em relação ao \est{ASP.NET MVC} nesse aspecto. Além de precisar adquirir uma biblioteca externa (o \est{Ninject}, utilizado como exemplo) também foi necessária configuração adicional para cada classe a ser injetada no projeto \sigla{.NET}.
  \item Criação de entidades - Pela não necessidade da criação de um contexto do banco de dados e possuir atualização da estrutura do banco de forma automática, o \est{Hibernate} implementando o \sigla{JPA} se mostrou superior ao \est{Entity Framework}, apesar de requerer que as entidades sejam decoradas com várias anotações.
  \item Criação de repositórios - A sintaxe fluente do \lang{LINQ} (\sigla{.NET}) se mostrou superior ao \lang{JPQL} (\lang{Java}/\sigla{JPA}) por utilizar expressões \est{lambda}, ser fortemente tipada e fazer uso das funções de auto completar código do \est{Visual Studio}. Apesar disso, desenvolvedores mais familiarizados em trabalhar com \est{scripts} \lang{SQL} podem preferir o \lang{JPQL}. Em relação ao controle de transações, o \est{Spring Framework} se mostrou superior, pois automatiza a criação e reuso de transações ao mesmo tempo que dá ao desenvolvedor controle sobre elas. 
\end{itemize}

Existem outras carateristas inerentes às tecnologias utilizadas que devem ser lavadas em consideração na hora de escolher alguma delas para um novo projeto. A versão atual do \est{ASP.NET} por exemplo, não funciona em sistemas operacionais que não sejam o \est{Windows}. Então se nos requisitos do sistema especificasse que ele deve rodar em \est{Linux}, por exemplo, \lang{Java} deverá ser a escolha entre as duas tecnologias. A familiaridade da equipe de desenvolvimento e suas preferencias subjetivas também impactam na escolha da tecnologia.

De modo geral, a conclusão a que esse trabalho chega é que se um projeto precisar ficar pronto rápido e a equipe de desenvolvimento não tiver uma preferencia clara por uma tecnologia, o uso do \est{ASP.NET} pode ser uma boa opção. Em contra partida, se o time de desenvolvimento quiser ter controle granular sobre o projeto, dispor de tempo para testar várias soluções diferentes e dominar o \est{Spring Framework}, utilizar o ambiente \lang{Java} é uma melhor opção.

Como trabalho futuro, o desempenho das duas tecnologias pode ser analisado. Quando o \est{ASP.NET MVC 6} for lançado, pode ser feita uma nova comparação para desenvolvimento em ambiente \est{Linux}. Pode-se também utilizar o \est{Spring Boot} em um trabalho futuro e verificar como ele auxilia a configuração de um projeto \lang{Java}.

Esse trabalho foi importante para auxiliar a ter uma compreensão melhor das vantagens e desvantagens entre as duas tecnologias de modo mais lógico. Ouve-se muitas discussões entre desenvolvedores em momentos de descontração que dizem preferir uma tecnologia à outra por motivos subjetivos, muitos deles não conhecendo realmente a tecnologia rival. Assim, esse trabalho também auxilia desenvolvedores experientes em fundamentar seus elogios e críticas à uma ou outra tecnologia.

\end{document}